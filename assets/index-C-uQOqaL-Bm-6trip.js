function _(e){return new TextEncoder().encode(e)}function l(e){const t=new Uint8Array(e);let r="";for(const o of t)r+=String.fromCharCode(o);return btoa(r).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function f(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),r=(4-t.length%4)%4,o=t.padEnd(t.length+r,"="),a=atob(o),n=new ArrayBuffer(a.length),d=new Uint8Array(n);for(let c=0;c<a.length;c++)d[c]=a.charCodeAt(c);return n}function E(){return(window==null?void 0:window.PublicKeyCredential)!==void 0&&typeof window.PublicKeyCredential=="function"}function A(e){const{id:t}=e;return{...e,id:f(t),transports:e.transports}}function g(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class i extends Error{constructor({message:t,code:r,cause:o,name:a}){super(t,{cause:o}),this.name=a??o.name,this.code=r}}function O({error:e,options:t}){var o,a;const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new i({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(((o=r.authenticatorSelection)==null?void 0:o.requireResidentKey)===!0)return new i({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(((a=r.authenticatorSelection)==null?void 0:a.userVerification)==="required")return new i({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new i({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new i({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return r.pubKeyCredParams.filter(n=>n.type==="public-key").length===0?new i({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new i({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const n=window.location.hostname;if(g(n)){if(r.rp.id!==n)return new i({message:`The RP ID "${r.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new i({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(r.user.id.byteLength<1||r.user.id.byteLength>64)return new i({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new i({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class I{createNewAbortSignal(){if(this.controller){const r=new Error("Cancelling existing WebAuthn API call for new one");r.name="AbortError",this.controller.abort(r)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const m=new I,S=["cross-platform","platform"];function b(e){if(e&&!(S.indexOf(e)<0))return e}async function N(e){var w;if(!E())throw new Error("WebAuthn is not supported in this browser");const t={publicKey:{...e,challenge:f(e.challenge),user:{...e.user,id:_(e.user.id)},excludeCredentials:(w=e.excludeCredentials)==null?void 0:w.map(A)}};t.signal=m.createNewAbortSignal();let r;try{r=await navigator.credentials.create(t)}catch(s){throw O({error:s,options:t})}if(!r)throw new Error("Registration was not completed");const{id:o,rawId:a,response:n,type:d}=r;let c;typeof n.getTransports=="function"&&(c=n.getTransports());let u;if(typeof n.getPublicKeyAlgorithm=="function")try{u=n.getPublicKeyAlgorithm()}catch(s){p("getPublicKeyAlgorithm()",s)}let R;if(typeof n.getPublicKey=="function")try{const s=n.getPublicKey();s!==null&&(R=l(s))}catch(s){p("getPublicKey()",s)}let h;if(typeof n.getAuthenticatorData=="function")try{h=l(n.getAuthenticatorData())}catch(s){p("getAuthenticatorData()",s)}return{id:o,rawId:l(a),response:{attestationObject:l(n.attestationObject),clientDataJSON:l(n.clientDataJSON),transports:c,publicKeyAlgorithm:u,publicKey:R,authenticatorData:h},type:d,clientExtensionResults:r.getClientExtensionResults(),authenticatorAttachment:b(r.authenticatorAttachment)}}function p(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function T(e){return new TextDecoder("utf-8").decode(e)}function P(){const e=window.PublicKeyCredential;return e.isConditionalMediationAvailable===void 0?new Promise(t=>t(!1)):e.isConditionalMediationAvailable()}function C({error:e,options:t}){const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new i({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new i({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const o=window.location.hostname;if(g(o)){if(r.rpId!==o)return new i({message:`The RP ID "${r.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new i({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new i({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function D(e,t=!1){var w,s;if(!E())throw new Error("WebAuthn is not supported in this browser");let r;((w=e.allowCredentials)==null?void 0:w.length)!==0&&(r=(s=e.allowCredentials)==null?void 0:s.map(A));const o={...e,challenge:f(e.challenge),allowCredentials:r},a={};if(t){if(!await P())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');a.mediation="conditional",o.allowCredentials=[]}a.publicKey=o,a.signal=m.createNewAbortSignal();let n;try{n=await navigator.credentials.get(a)}catch(y){throw C({error:y,options:a})}if(!n)throw new Error("Authentication was not completed");const{id:d,rawId:c,response:u,type:R}=n;let h;return u.userHandle&&(h=T(u.userHandle)),{id:d,rawId:l(c),response:{authenticatorData:l(u.authenticatorData),clientDataJSON:l(u.clientDataJSON),signature:l(u.signature),userHandle:h},type:R,clientExtensionResults:n.getClientExtensionResults(),authenticatorAttachment:b(n.authenticatorAttachment)}}function U(){return E()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}export{m as WebAuthnAbortService,i as WebAuthnError,f as base64URLStringToBuffer,E as browserSupportsWebAuthn,P as browserSupportsWebAuthnAutofill,l as bufferToBase64URLString,U as platformAuthenticatorIsAvailable,D as startAuthentication,N as startRegistration};
