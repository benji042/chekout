import{ay as Ee,az as be,aA as Be,aB as pt,aC as Xt,aD as ve,aE as $t,aF as yt,aG as te,aH as xe,aI as St,aJ as Se,aK as M}from"./index-m-1z-isx.js";function Ie(r,e,t,n){if(typeof r.setBigUint64=="function")return r.setBigUint64(e,t,n);const o=BigInt(32),s=BigInt(4294967295),a=Number(t>>o&s),f=Number(t&s),i=n?4:0,l=n?0:4;r.setUint32(e+i,a,n),r.setUint32(e+l,f,n)}function Oe(r,e,t){return r&e^~r&t}function Ae(r,e,t){return r&e^r&t^e&t}class Ne extends Xt{constructor(e,t,n,o){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=t,this.padOffset=n,this.isLE=o,this.buffer=new Uint8Array(e),this.view=St(this.buffer)}update(e){yt(this),e=$t(e),te(e);const{view:t,buffer:n,blockLen:o}=this,s=e.length;for(let a=0;a<s;){const f=Math.min(o-this.pos,s-a);if(f===o){const i=St(e);for(;o<=s-a;a+=o)this.process(i,a);continue}n.set(e.subarray(a,a+f),this.pos),this.pos+=f,a+=f,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){yt(this),Se(e,this),this.finished=!0;const{buffer:t,view:n,blockLen:o,isLE:s}=this;let{pos:a}=this;t[a++]=128,pt(this.buffer.subarray(a)),this.padOffset>o-a&&(this.process(n,0),a=0);for(let g=a;g<o;g++)t[g]=0;Ie(n,o-8,BigInt(this.length*8),s),this.process(n,0);const f=St(e),i=this.outputLen;if(i%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=i/4,d=this.get();if(l>d.length)throw new Error("_sha2: outputLen bigger than state");for(let g=0;g<l;g++)f.setUint32(4*g,d[g],s)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const n=e.slice(0,t);return this.destroy(),n}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:n,length:o,finished:s,destroyed:a,pos:f}=this;return e.destroyed=a,e.finished=s,e.length=o,e.pos=f,o%t&&e.buffer.set(n),e}clone(){return this._cloneInto()}}const $=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),qe=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),tt=new Uint32Array(64);class Re extends Ne{constructor(e=32){super(64,e,8,!1),this.A=$[0]|0,this.B=$[1]|0,this.C=$[2]|0,this.D=$[3]|0,this.E=$[4]|0,this.F=$[5]|0,this.G=$[6]|0,this.H=$[7]|0}get(){const{A:e,B:t,C:n,D:o,E:s,F:a,G:f,H:i}=this;return[e,t,n,o,s,a,f,i]}set(e,t,n,o,s,a,f,i){this.A=e|0,this.B=t|0,this.C=n|0,this.D=o|0,this.E=s|0,this.F=a|0,this.G=f|0,this.H=i|0}process(e,t){for(let g=0;g<16;g++,t+=4)tt[g]=e.getUint32(t,!1);for(let g=16;g<64;g++){const x=tt[g-15],R=tt[g-2],U=M(x,7)^M(x,18)^x>>>3,y=M(R,17)^M(R,19)^R>>>10;tt[g]=y+tt[g-7]+U+tt[g-16]|0}let{A:n,B:o,C:s,D:a,E:f,F:i,G:l,H:d}=this;for(let g=0;g<64;g++){const x=M(f,6)^M(f,11)^M(f,25),R=d+x+Oe(f,i,l)+qe[g]+tt[g]|0,U=(M(n,2)^M(n,13)^M(n,22))+Ae(n,o,s)|0;d=l,l=i,i=f,f=a+R|0,a=s,s=o,o=n,n=R+U|0}n=n+this.A|0,o=o+this.B|0,s=s+this.C|0,a=a+this.D|0,f=f+this.E|0,i=i+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(n,o,s,a,f,i,l,d)}roundClean(){pt(tt)}destroy(){this.set(0,0,0,0,0,0,0,0),pt(this.buffer)}}const Le=Be(()=>new Re);class ee extends Xt{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,ve(e);const n=$t(t);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(n.length>o?e.create().update(n).digest():n);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=e.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),pt(s)}update(e){return yt(this),this.iHash.update(e),this}digestInto(e){yt(this),te(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:n,finished:o,destroyed:s,blockLen:a,outputLen:f}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=a,e.outputLen=f,e.oHash=t._cloneInto(e.oHash),e.iHash=n._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const re=(r,e,t)=>new ee(r,e).update(t).digest();re.create=(r,e)=>new ee(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ct=BigInt(0),Ut=BigInt(1);function dt(r){return r instanceof Uint8Array||ArrayBuffer.isView(r)&&r.constructor.name==="Uint8Array"}function Zt(r){if(!dt(r))throw new Error("Uint8Array expected")}function lt(r,e){if(typeof e!="boolean")throw new Error(r+" boolean expected, got "+e)}function gt(r){const e=r.toString(16);return e.length&1?"0"+e:e}function ne(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?Ct:BigInt("0x"+r)}const ie=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",He=Array.from({length:256},(r,e)=>e.toString(16).padStart(2,"0"));function ht(r){if(Zt(r),ie)return r.toHex();let e="";for(let t=0;t<r.length;t++)e+=He[r[t]];return e}const _={_0:48,_9:57,A:65,F:70,a:97,f:102};function jt(r){if(r>=_._0&&r<=_._9)return r-_._0;if(r>=_.A&&r<=_.F)return r-(_.A-10);if(r>=_.a&&r<=_.f)return r-(_.a-10)}function mt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);if(ie)return Uint8Array.fromHex(r);const e=r.length,t=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(t);for(let o=0,s=0;o<t;o++,s+=2){const a=jt(r.charCodeAt(s)),f=jt(r.charCodeAt(s+1));if(a===void 0||f===void 0){const i=r[s]+r[s+1];throw new Error('hex string expected, got non-hex character "'+i+'" at index '+s)}n[o]=a*16+f}return n}function ot(r){return ne(ht(r))}function oe(r){return Zt(r),ne(ht(Uint8Array.from(r).reverse()))}function wt(r,e){return mt(r.toString(16).padStart(e*2,"0"))}function se(r,e){return wt(r,e).reverse()}function K(r,e,t){let n;if(typeof e=="string")try{n=mt(e)}catch(s){throw new Error(r+" must be hex string or Uint8Array, cause: "+s)}else if(dt(e))n=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");const o=n.length;if(typeof t=="number"&&o!==t)throw new Error(r+" of length "+t+" expected, got "+o);return n}function Et(...r){let e=0;for(let n=0;n<r.length;n++){const o=r[n];Zt(o),e+=o.length}const t=new Uint8Array(e);for(let n=0,o=0;n<r.length;n++){const s=r[n];t.set(s,o),o+=s.length}return t}const It=r=>typeof r=="bigint"&&Ct<=r;function Tt(r,e,t){return It(r)&&It(e)&&It(t)&&e<=r&&r<t}function at(r,e,t,n){if(!Tt(e,t,n))throw new Error("expected valid "+r+": "+t+" <= n < "+n+", got "+e)}function Ue(r){let e;for(e=0;r>Ct;r>>=Ut,e+=1);return e}const bt=r=>(Ut<<BigInt(r))-Ut,Ot=r=>new Uint8Array(r),Kt=r=>Uint8Array.from(r);function Fe(r,e,t){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let n=Ot(r),o=Ot(r),s=0;const a=()=>{n.fill(1),o.fill(0),s=0},f=(...d)=>t(o,n,...d),i=(d=Ot(0))=>{o=f(Kt([0]),d),n=f(),d.length!==0&&(o=f(Kt([1]),d),n=f())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let d=0;const g=[];for(;d<e;){n=f();const x=n.slice();g.push(x),d+=n.length}return Et(...g)};return(d,g)=>{a(),i(d);let x;for(;!(x=g(l()));)i();return a(),x}}const ze={bigint:r=>typeof r=="bigint",function:r=>typeof r=="function",boolean:r=>typeof r=="boolean",string:r=>typeof r=="string",stringOrUint8Array:r=>typeof r=="string"||dt(r),isSafeInteger:r=>Number.isSafeInteger(r),array:r=>Array.isArray(r),field:(r,e)=>e.Fp.isValid(r),hash:r=>typeof r=="function"&&Number.isSafeInteger(r.outputLen)};function Bt(r,e,t={}){const n=(o,s,a)=>{const f=ze[s];if(typeof f!="function")throw new Error("invalid validator function");const i=r[o];if(!(a&&i===void 0)&&!f(i,r))throw new Error("param "+String(o)+" is invalid. Expected "+s+", got "+i)};for(const[o,s]of Object.entries(e))n(o,s,!1);for(const[o,s]of Object.entries(t))n(o,s,!0);return r}function Wt(r){const e=new WeakMap;return(t,...n)=>{const o=e.get(t);if(o!==void 0)return o;const s=r(t,...n);return e.set(t,s),s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D=BigInt(0),Z=BigInt(1),it=BigInt(2),ke=BigInt(3),fe=BigInt(4),ae=BigInt(5),ce=BigInt(8);function T(r,e){const t=r%e;return t>=D?t:e+t}function j(r,e,t){let n=r;for(;e-- >D;)n*=n,n%=t;return n}function Ft(r,e){if(r===D)throw new Error("invert: expected non-zero number");if(e<=D)throw new Error("invert: expected positive modulus, got "+e);let t=T(r,e),n=e,o=D,s=Z;for(;t!==D;){const a=n/t,f=n%t,i=o-s*a;n=t,t=f,o=s,s=i}if(n!==Z)throw new Error("invert: does not exist");return T(o,e)}function ue(r,e){const t=(r.ORDER+Z)/fe,n=r.pow(e,t);if(!r.eql(r.sqr(n),e))throw new Error("Cannot find square root");return n}function Pe(r,e){const t=(r.ORDER-ae)/ce,n=r.mul(e,it),o=r.pow(n,t),s=r.mul(e,o),a=r.mul(r.mul(s,it),o),f=r.mul(s,r.sub(a,r.ONE));if(!r.eql(r.sqr(f),e))throw new Error("Cannot find square root");return f}function Ce(r){if(r<BigInt(3))throw new Error("sqrt is not defined for small field");let e=r-Z,t=0;for(;e%it===D;)e/=it,t++;let n=it;const o=Dt(r);for(;Yt(o,n)===1;)if(n++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return ue;let s=o.pow(n,e);const a=(e+Z)/it;return function(f,i){if(f.is0(i))return i;if(Yt(f,i)!==1)throw new Error("Cannot find square root");let l=t,d=f.mul(f.ONE,s),g=f.pow(i,e),x=f.pow(i,a);for(;!f.eql(g,f.ONE);){if(f.is0(g))return f.ZERO;let R=1,U=f.sqr(g);for(;!f.eql(U,f.ONE);)if(R++,U=f.sqr(U),R===l)throw new Error("Cannot find square root");const y=Z<<BigInt(l-R-1),k=f.pow(d,y);l=R,d=f.sqr(k),g=f.mul(g,d),x=f.mul(x,k)}return x}}function Ze(r){return r%fe===ke?ue:r%ce===ae?Pe:Ce(r)}const Te=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function De(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Te.reduce((n,o)=>(n[o]="function",n),e);return Bt(r,t)}function Ve(r,e,t){if(t<D)throw new Error("invalid exponent, negatives unsupported");if(t===D)return r.ONE;if(t===Z)return e;let n=r.ONE,o=e;for(;t>D;)t&Z&&(n=r.mul(n,o)),o=r.sqr(o),t>>=Z;return n}function le(r,e,t=!1){const n=new Array(e.length).fill(t?r.ZERO:void 0),o=e.reduce((a,f,i)=>r.is0(f)?a:(n[i]=a,r.mul(a,f)),r.ONE),s=r.inv(o);return e.reduceRight((a,f,i)=>r.is0(f)?a:(n[i]=r.mul(a,n[i]),r.mul(a,f)),s),n}function Yt(r,e){const t=(r.ORDER-Z)/it,n=r.pow(e,t),o=r.eql(n,r.ONE),s=r.eql(n,r.ZERO),a=r.eql(n,r.neg(r.ONE));if(!o&&!s&&!a)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function he(r,e){e!==void 0&&xe(e);const t=e!==void 0?e:r.toString(2).length,n=Math.ceil(t/8);return{nBitLength:t,nByteLength:n}}function Dt(r,e,t=!1,n={}){if(r<=D)throw new Error("invalid field: expected ORDER > 0, got "+r);const{nBitLength:o,nByteLength:s}=he(r,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const f=Object.freeze({ORDER:r,isLE:t,BITS:o,BYTES:s,MASK:bt(o),ZERO:D,ONE:Z,create:i=>T(i,r),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return D<=i&&i<r},is0:i=>i===D,isOdd:i=>(i&Z)===Z,neg:i=>T(-i,r),eql:(i,l)=>i===l,sqr:i=>T(i*i,r),add:(i,l)=>T(i+l,r),sub:(i,l)=>T(i-l,r),mul:(i,l)=>T(i*l,r),pow:(i,l)=>Ve(f,i,l),div:(i,l)=>T(i*Ft(l,r),r),sqrN:i=>i*i,addN:(i,l)=>i+l,subN:(i,l)=>i-l,mulN:(i,l)=>i*l,inv:i=>Ft(i,r),sqrt:n.sqrt||(i=>(a||(a=Ze(r)),a(f,i))),toBytes:i=>t?se(i,s):wt(i,s),fromBytes:i=>{if(i.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+i.length);return t?oe(i):ot(i)},invertBatch:i=>le(f,i),cmov:(i,l,d)=>d?l:i});return Object.freeze(f)}function de(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function we(r){const e=de(r);return e+Math.ceil(e/2)}function je(r,e,t=!1){const n=r.length,o=de(e),s=we(e);if(n<16||n<s||n>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+n);const a=t?oe(r):ot(r),f=T(a,e-Z)+Z;return t?se(f,o):wt(f,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Gt=BigInt(0),zt=BigInt(1);function At(r,e){const t=e.negate();return r?t:e}function ge(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function Nt(r,e){ge(r,e);const t=Math.ceil(e/r)+1,n=2**(r-1),o=2**r,s=bt(r),a=BigInt(r);return{windows:t,windowSize:n,mask:s,maxNumber:o,shiftBy:a}}function Mt(r,e,t){const{windowSize:n,mask:o,maxNumber:s,shiftBy:a}=t;let f=Number(r&o),i=r>>a;f>n&&(f-=s,i+=zt);const l=e*n,d=l+Math.abs(f)-1,g=f===0,x=f<0,R=e%2!==0;return{nextN:i,offset:d,isZero:g,isNeg:x,isNegF:R,offsetF:l}}function Ke(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)})}function We(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)})}const qt=new WeakMap,pe=new WeakMap;function Rt(r){return pe.get(r)||1}function Ye(r,e){return{constTimeNegate:At,hasPrecomputes(t){return Rt(t)!==1},unsafeLadder(t,n,o=r.ZERO){let s=t;for(;n>Gt;)n&zt&&(o=o.add(s)),s=s.double(),n>>=zt;return o},precomputeWindow(t,n){const{windows:o,windowSize:s}=Nt(n,e),a=[];let f=t,i=f;for(let l=0;l<o;l++){i=f,a.push(i);for(let d=1;d<s;d++)i=i.add(f),a.push(i);f=i.double()}return a},wNAF(t,n,o){let s=r.ZERO,a=r.BASE;const f=Nt(t,e);for(let i=0;i<f.windows;i++){const{nextN:l,offset:d,isZero:g,isNeg:x,isNegF:R,offsetF:U}=Mt(o,i,f);o=l,g?a=a.add(At(R,n[U])):s=s.add(At(x,n[d]))}return{p:s,f:a}},wNAFUnsafe(t,n,o,s=r.ZERO){const a=Nt(t,e);for(let f=0;f<a.windows&&o!==Gt;f++){const{nextN:i,offset:l,isZero:d,isNeg:g}=Mt(o,f,a);if(o=i,!d){const x=n[l];s=s.add(g?x.negate():x)}}return s},getPrecomputes(t,n,o){let s=qt.get(n);return s||(s=this.precomputeWindow(n,t),t!==1&&qt.set(n,o(s))),s},wNAFCached(t,n,o){const s=Rt(t);return this.wNAF(s,this.getPrecomputes(s,t,o),n)},wNAFCachedUnsafe(t,n,o,s){const a=Rt(t);return a===1?this.unsafeLadder(t,n,s):this.wNAFUnsafe(a,this.getPrecomputes(a,t,o),n,s)},setWindowSize(t,n){ge(n,e),pe.set(t,n),qt.delete(t)}}}function Ge(r,e,t,n){Ke(t,r),We(n,e);const o=t.length,s=n.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");const a=r.ZERO,f=Ue(BigInt(o));let i=1;f>12?i=f-3:f>4?i=f-2:f>0&&(i=2);const l=bt(i),d=new Array(Number(l)+1).fill(a),g=Math.floor((e.BITS-1)/i)*i;let x=a;for(let R=g;R>=0;R-=i){d.fill(a);for(let y=0;y<s;y++){const k=n[y],F=Number(k>>BigInt(R)&l);d[F]=d[F].add(t[y])}let U=a;for(let y=d.length-1,k=a;y>0;y--)k=k.add(d[y]),U=U.add(k);if(x=x.add(U),R!==0)for(let y=0;y<i;y++)x=x.double()}return x}function ye(r){return De(r.Fp),Bt(r,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...he(r.n,r.nBitLength),...r,p:r.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function _t(r){r.lowS!==void 0&&lt("lowS",r.lowS),r.prehash!==void 0&&lt("prehash",r.prehash)}function Me(r){const e=ye(r);Bt(e,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});const{endo:t,Fp:n,a:o}=e;if(t){if(!n.eql(o,n.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...e})}class _e extends Error{constructor(e=""){super(e)}}const Q={Err:_e,_tlv:{encode:(r,e)=>{const{Err:t}=Q;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length&1)throw new t("tlv.encode: unpadded data");const n=e.length/2,o=gt(n);if(o.length/2&128)throw new t("tlv.encode: long form length too big");const s=n>127?gt(o.length/2|128):"";return gt(r)+s+o+e},decode(r,e){const{Err:t}=Q;let n=0;if(r<0||r>256)throw new t("tlv.encode: wrong tag");if(e.length<2||e[n++]!==r)throw new t("tlv.decode: wrong tlv");const o=e[n++],s=!!(o&128);let a=0;if(!s)a=o;else{const i=o&127;if(!i)throw new t("tlv.decode(long): indefinite length not supported");if(i>4)throw new t("tlv.decode(long): byte length is too big");const l=e.subarray(n,n+i);if(l.length!==i)throw new t("tlv.decode: length bytes not complete");if(l[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(const d of l)a=a<<8|d;if(n+=i,a<128)throw new t("tlv.decode(long): not minimal encoding")}const f=e.subarray(n,n+a);if(f.length!==a)throw new t("tlv.decode: wrong value length");return{v:f,l:e.subarray(n+a)}}},_int:{encode(r){const{Err:e}=Q;if(r<J)throw new e("integer: negative integers are not allowed");let t=gt(r);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return t},decode(r){const{Err:e}=Q;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return ot(r)}},toSig(r){const{Err:e,_int:t,_tlv:n}=Q,o=K("signature",r),{v:s,l:a}=n.decode(48,o);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:f,l:i}=n.decode(2,s),{v:l,l:d}=n.decode(2,i);if(d.length)throw new e("invalid signature: left bytes after parsing");return{r:t.decode(f),s:t.decode(l)}},hexFromSig(r){const{_tlv:e,_int:t}=Q,n=e.encode(2,t.encode(r.r)),o=e.encode(2,t.encode(r.s)),s=n+o;return e.encode(48,s)}};function Lt(r,e){return ht(wt(r,e))}const J=BigInt(0),z=BigInt(1);BigInt(2);const Ht=BigInt(3),Qe=BigInt(4);function Je(r){const e=Me(r),{Fp:t}=e,n=Dt(e.n,e.nBitLength),o=e.toBytes||((S,c,w)=>{const m=c.toAffine();return Et(Uint8Array.from([4]),t.toBytes(m.x),t.toBytes(m.y))}),s=e.fromBytes||(S=>{const c=S.subarray(1),w=t.fromBytes(c.subarray(0,t.BYTES)),m=t.fromBytes(c.subarray(t.BYTES,2*t.BYTES));return{x:w,y:m}});function a(S){const{a:c,b:w}=e,m=t.sqr(S),v=t.mul(m,S);return t.add(t.add(v,t.mul(S,c)),w)}function f(S,c){const w=t.sqr(c),m=a(S);return t.eql(w,m)}if(!f(e.Gx,e.Gy))throw new Error("bad curve params: generator point");const i=t.mul(t.pow(e.a,Ht),Qe),l=t.mul(t.sqr(e.b),BigInt(27));if(t.is0(t.add(i,l)))throw new Error("bad curve params: a or b");function d(S){return Tt(S,z,e.n)}function g(S){const{allowedPrivateKeyLengths:c,nByteLength:w,wrapPrivateKey:m,n:v}=e;if(c&&typeof S!="bigint"){if(dt(S)&&(S=ht(S)),typeof S!="string"||!c.includes(S.length))throw new Error("invalid private key");S=S.padStart(w*2,"0")}let N;try{N=typeof S=="bigint"?S:ot(K("private key",S,w))}catch{throw new Error("invalid private key, expected hex or "+w+" bytes, got "+typeof S)}return m&&(N=T(N,v)),at("private key",N,z,v),N}function x(S){if(!(S instanceof y))throw new Error("ProjectivePoint expected")}const R=Wt((S,c)=>{const{px:w,py:m,pz:v}=S;if(t.eql(v,t.ONE))return{x:w,y:m};const N=S.is0();c==null&&(c=N?t.ONE:t.inv(v));const L=t.mul(w,c),q=t.mul(m,c),E=t.mul(v,c);if(N)return{x:t.ZERO,y:t.ZERO};if(!t.eql(E,t.ONE))throw new Error("invZ was invalid");return{x:L,y:q}}),U=Wt(S=>{if(S.is0()){if(e.allowInfinityPoint&&!t.is0(S.py))return;throw new Error("bad point: ZERO")}const{x:c,y:w}=S.toAffine();if(!t.isValid(c)||!t.isValid(w))throw new Error("bad point: x or y not FE");if(!f(c,w))throw new Error("bad point: equation left != right");if(!S.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class y{constructor(c,w,m){if(c==null||!t.isValid(c))throw new Error("x required");if(w==null||!t.isValid(w)||t.is0(w))throw new Error("y required");if(m==null||!t.isValid(m))throw new Error("z required");this.px=c,this.py=w,this.pz=m,Object.freeze(this)}static fromAffine(c){const{x:w,y:m}=c||{};if(!c||!t.isValid(w)||!t.isValid(m))throw new Error("invalid affine point");if(c instanceof y)throw new Error("projective point not allowed");const v=N=>t.eql(N,t.ZERO);return v(w)&&v(m)?y.ZERO:new y(w,m,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(c){const w=le(t,c.map(m=>m.pz));return c.map((m,v)=>m.toAffine(w[v])).map(y.fromAffine)}static fromHex(c){const w=y.fromAffine(s(K("pointHex",c)));return w.assertValidity(),w}static fromPrivateKey(c){return y.BASE.multiply(g(c))}static msm(c,w){return Ge(y,n,c,w)}_setWindowSize(c){Y.setWindowSize(this,c)}assertValidity(){U(this)}hasEvenY(){const{y:c}=this.toAffine();if(t.isOdd)return!t.isOdd(c);throw new Error("Field doesn't support isOdd")}equals(c){x(c);const{px:w,py:m,pz:v}=this,{px:N,py:L,pz:q}=c,E=t.eql(t.mul(w,q),t.mul(N,v)),A=t.eql(t.mul(m,q),t.mul(L,v));return E&&A}negate(){return new y(this.px,t.neg(this.py),this.pz)}double(){const{a:c,b:w}=e,m=t.mul(w,Ht),{px:v,py:N,pz:L}=this;let q=t.ZERO,E=t.ZERO,A=t.ZERO,b=t.mul(v,v),P=t.mul(N,N),h=t.mul(L,L),u=t.mul(v,N);return u=t.add(u,u),A=t.mul(v,L),A=t.add(A,A),q=t.mul(c,A),E=t.mul(m,h),E=t.add(q,E),q=t.sub(P,E),E=t.add(P,E),E=t.mul(q,E),q=t.mul(u,q),A=t.mul(m,A),h=t.mul(c,h),u=t.sub(b,h),u=t.mul(c,u),u=t.add(u,A),A=t.add(b,b),b=t.add(A,b),b=t.add(b,h),b=t.mul(b,u),E=t.add(E,b),h=t.mul(N,L),h=t.add(h,h),b=t.mul(h,u),q=t.sub(q,b),A=t.mul(h,P),A=t.add(A,A),A=t.add(A,A),new y(q,E,A)}add(c){x(c);const{px:w,py:m,pz:v}=this,{px:N,py:L,pz:q}=c;let E=t.ZERO,A=t.ZERO,b=t.ZERO;const P=e.a,h=t.mul(e.b,Ht);let u=t.mul(w,N),p=t.mul(m,L),I=t.mul(v,q),B=t.add(w,m),O=t.add(N,L);B=t.mul(B,O),O=t.add(u,p),B=t.sub(B,O),O=t.add(w,v);let H=t.add(N,q);return O=t.mul(O,H),H=t.add(u,I),O=t.sub(O,H),H=t.add(m,v),E=t.add(L,q),H=t.mul(H,E),E=t.add(p,I),H=t.sub(H,E),b=t.mul(P,O),E=t.mul(h,I),b=t.add(E,b),E=t.sub(p,b),b=t.add(p,b),A=t.mul(E,b),p=t.add(u,u),p=t.add(p,u),I=t.mul(P,I),O=t.mul(h,O),p=t.add(p,I),I=t.sub(u,I),I=t.mul(P,I),O=t.add(O,I),u=t.mul(p,O),A=t.add(A,u),u=t.mul(H,O),E=t.mul(B,E),E=t.sub(E,u),u=t.mul(B,p),b=t.mul(H,b),b=t.add(b,u),new y(E,A,b)}subtract(c){return this.add(c.negate())}is0(){return this.equals(y.ZERO)}wNAF(c){return Y.wNAFCached(this,c,y.normalizeZ)}multiplyUnsafe(c){const{endo:w,n:m}=e;at("scalar",c,J,m);const v=y.ZERO;if(c===J)return v;if(this.is0()||c===z)return this;if(!w||Y.hasPrecomputes(this))return Y.wNAFCachedUnsafe(this,c,y.normalizeZ);let{k1neg:N,k1:L,k2neg:q,k2:E}=w.splitScalar(c),A=v,b=v,P=this;for(;L>J||E>J;)L&z&&(A=A.add(P)),E&z&&(b=b.add(P)),P=P.double(),L>>=z,E>>=z;return N&&(A=A.negate()),q&&(b=b.negate()),b=new y(t.mul(b.px,w.beta),b.py,b.pz),A.add(b)}multiply(c){const{endo:w,n:m}=e;at("scalar",c,z,m);let v,N;if(w){const{k1neg:L,k1:q,k2neg:E,k2:A}=w.splitScalar(c);let{p:b,f:P}=this.wNAF(q),{p:h,f:u}=this.wNAF(A);b=Y.constTimeNegate(L,b),h=Y.constTimeNegate(E,h),h=new y(t.mul(h.px,w.beta),h.py,h.pz),v=b.add(h),N=P.add(u)}else{const{p:L,f:q}=this.wNAF(c);v=L,N=q}return y.normalizeZ([v,N])[0]}multiplyAndAddUnsafe(c,w,m){const v=y.BASE,N=(q,E)=>E===J||E===z||!q.equals(v)?q.multiplyUnsafe(E):q.multiply(E),L=N(this,w).add(N(c,m));return L.is0()?void 0:L}toAffine(c){return R(this,c)}isTorsionFree(){const{h:c,isTorsionFree:w}=e;if(c===z)return!0;if(w)return w(y,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:c,clearCofactor:w}=e;return c===z?this:w?w(y,this):this.multiplyUnsafe(e.h)}toRawBytes(c=!0){return lt("isCompressed",c),this.assertValidity(),o(y,this,c)}toHex(c=!0){return lt("isCompressed",c),ht(this.toRawBytes(c))}}y.BASE=new y(e.Gx,e.Gy,t.ONE),y.ZERO=new y(t.ZERO,t.ONE,t.ZERO);const{endo:k,nBitLength:F}=e,Y=Ye(y,k?Math.ceil(F/2):F);return{CURVE:e,ProjectivePoint:y,normPrivateKeyToScalar:g,weierstrassEquation:a,isWithinCurveOrder:d}}function Xe(r){const e=ye(r);return Bt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function $e(r){const e=Xe(r),{Fp:t,n,nByteLength:o,nBitLength:s}=e,a=t.BYTES+1,f=2*t.BYTES+1;function i(h){return T(h,n)}function l(h){return Ft(h,n)}const{ProjectivePoint:d,normPrivateKeyToScalar:g,weierstrassEquation:x,isWithinCurveOrder:R}=Je({...e,toBytes(h,u,p){const I=u.toAffine(),B=t.toBytes(I.x),O=Et;return lt("isCompressed",p),p?O(Uint8Array.from([u.hasEvenY()?2:3]),B):O(Uint8Array.from([4]),B,t.toBytes(I.y))},fromBytes(h){const u=h.length,p=h[0],I=h.subarray(1);if(u===a&&(p===2||p===3)){const B=ot(I);if(!Tt(B,z,t.ORDER))throw new Error("Point is not on curve");const O=x(B);let H;try{H=t.sqrt(O)}catch(W){const G=W instanceof Error?": "+W.message:"";throw new Error("Point is not on curve"+G)}const C=(H&z)===z;return(p&1)===1!==C&&(H=t.neg(H)),{x:B,y:H}}else if(u===f&&p===4){const B=t.fromBytes(I.subarray(0,t.BYTES)),O=t.fromBytes(I.subarray(t.BYTES,2*t.BYTES));return{x:B,y:O}}else{const B=a,O=f;throw new Error("invalid Point, expected length of "+B+", or uncompressed "+O+", got "+u)}}});function U(h){const u=n>>z;return h>u}function y(h){return U(h)?i(-h):h}const k=(h,u,p)=>ot(h.slice(u,p));class F{constructor(u,p,I){at("r",u,z,n),at("s",p,z,n),this.r=u,this.s=p,I!=null&&(this.recovery=I),Object.freeze(this)}static fromCompact(u){const p=o;return u=K("compactSignature",u,p*2),new F(k(u,0,p),k(u,p,2*p))}static fromDER(u){const{r:p,s:I}=Q.toSig(K("DER",u));return new F(p,I)}assertValidity(){}addRecoveryBit(u){return new F(this.r,this.s,u)}recoverPublicKey(u){const{r:p,s:I,recovery:B}=this,O=v(K("msgHash",u));if(B==null||![0,1,2,3].includes(B))throw new Error("recovery id invalid");const H=B===2||B===3?p+e.n:p;if(H>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const C=B&1?"03":"02",W=d.fromHex(C+Lt(H,t.BYTES)),G=l(H),V=i(-O*G),st=i(I*G),X=d.BASE.multiplyAndAddUnsafe(W,V,st);if(!X)throw new Error("point at infinify");return X.assertValidity(),X}hasHighS(){return U(this.s)}normalizeS(){return this.hasHighS()?new F(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return mt(this.toDERHex())}toDERHex(){return Q.hexFromSig(this)}toCompactRawBytes(){return mt(this.toCompactHex())}toCompactHex(){const u=o;return Lt(this.r,u)+Lt(this.s,u)}}const Y={isValidPrivateKey(h){try{return g(h),!0}catch{return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const h=we(e.n);return je(e.randomBytes(h),e.n)},precompute(h=8,u=d.BASE){return u._setWindowSize(h),u.multiply(BigInt(3)),u}};function S(h,u=!0){return d.fromPrivateKey(h).toRawBytes(u)}function c(h){if(typeof h=="bigint")return!1;if(h instanceof d)return!0;const u=K("key",h).length,p=t.BYTES,I=p+1,B=2*p+1;if(!(e.allowedPrivateKeyLengths||o===I))return u===I||u===B}function w(h,u,p=!0){if(c(h)===!0)throw new Error("first arg must be private key");if(c(u)===!1)throw new Error("second arg must be public key");return d.fromHex(u).multiply(g(h)).toRawBytes(p)}const m=e.bits2int||function(h){if(h.length>8192)throw new Error("input is too large");const u=ot(h),p=h.length*8-s;return p>0?u>>BigInt(p):u},v=e.bits2int_modN||function(h){return i(m(h))},N=bt(s);function L(h){return at("num < 2^"+s,h,J,N),wt(h,o)}function q(h,u,p=E){if(["recovered","canonical"].some(et=>et in p))throw new Error("sign() legacy options not supported");const{hash:I,randomBytes:B}=e;let{lowS:O,prehash:H,extraEntropy:C}=p;O==null&&(O=!0),h=K("msgHash",h),_t(p),H&&(h=K("prehashed msgHash",I(h)));const W=v(h),G=g(u),V=[L(G),L(W)];if(C!=null&&C!==!1){const et=C===!0?B(t.BYTES):C;V.push(K("extraEntropy",et))}const st=Et(...V),X=W;function vt(et){const ft=m(et);if(!R(ft))return;const xt=l(ft),ct=d.BASE.multiply(ft).toAffine(),rt=i(ct.x);if(rt===J)return;const nt=i(xt*i(X+rt*G));if(nt===J)return;let ut=(ct.x===rt?0:2)|Number(ct.y&z),Vt=nt;return O&&U(nt)&&(Vt=y(nt),ut^=1),new F(rt,Vt,ut)}return{seed:st,k2sig:vt}}const E={lowS:e.lowS,prehash:!1},A={lowS:e.lowS,prehash:!1};function b(h,u,p=E){const{seed:I,k2sig:B}=q(h,u,p),O=e;return Fe(O.hash.outputLen,O.nByteLength,O.hmac)(I,B)}d.BASE._setWindowSize(8);function P(h,u,p,I=A){var nt;const B=h;u=K("msgHash",u),p=K("publicKey",p);const{lowS:O,prehash:H,format:C}=I;if(_t(I),"strict"in I)throw new Error("options.strict was renamed to lowS");if(C!==void 0&&C!=="compact"&&C!=="der")throw new Error("format must be compact or der");const W=typeof B=="string"||dt(B),G=!W&&!C&&typeof B=="object"&&B!==null&&typeof B.r=="bigint"&&typeof B.s=="bigint";if(!W&&!G)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let V,st;try{if(G&&(V=new F(B.r,B.s)),W){try{C!=="compact"&&(V=F.fromDER(B))}catch(ut){if(!(ut instanceof Q.Err))throw ut}!V&&C!=="der"&&(V=F.fromCompact(B))}st=d.fromHex(p)}catch{return!1}if(!V||O&&V.hasHighS())return!1;H&&(u=e.hash(u));const{r:X,s:vt}=V,et=v(u),ft=l(vt),xt=i(et*ft),ct=i(X*ft),rt=(nt=d.BASE.multiplyAndAddUnsafe(st,xt,ct))==null?void 0:nt.toAffine();return rt?i(rt.x)===X:!1}return{CURVE:e,getPublicKey:S,getSharedSecret:w,sign:b,verify:P,ProjectivePoint:d,Signature:F,utils:Y}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function tr(r){return{hash:r,hmac:(e,...t)=>re(r,e,Ee(...t)),randomBytes:be}}function er(r,e){const t=n=>$e({...r,...tr(n)});return{...t(e),create:t}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const me=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Qt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),rr=BigInt(0),nr=BigInt(1),kt=BigInt(2),Jt=(r,e)=>(r+e/kt)/e;function ir(r){const e=me,t=BigInt(3),n=BigInt(6),o=BigInt(11),s=BigInt(22),a=BigInt(23),f=BigInt(44),i=BigInt(88),l=r*r*r%e,d=l*l*r%e,g=j(d,t,e)*d%e,x=j(g,t,e)*d%e,R=j(x,kt,e)*l%e,U=j(R,o,e)*R%e,y=j(U,s,e)*U%e,k=j(y,f,e)*y%e,F=j(k,i,e)*k%e,Y=j(F,f,e)*y%e,S=j(Y,t,e)*d%e,c=j(S,a,e)*U%e,w=j(c,n,e)*l%e,m=j(w,kt,e);if(!Pt.eql(Pt.sqr(m),r))throw new Error("Cannot find square root");return m}const Pt=Dt(me,void 0,void 0,{sqrt:ir}),sr=er({a:rr,b:BigInt(7),Fp:Pt,n:Qt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:r=>{const e=Qt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-nr*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,a=BigInt("0x100000000000000000000000000000000"),f=Jt(s*r,e),i=Jt(-n*r,e);let l=T(r-f*t-i*o,e),d=T(-f*n-i*s,e);const g=l>a,x=d>a;if(g&&(l=e-l),x&&(d=e-d),l>a||d>a)throw new Error("splitScalar: Endomorphism failed, k="+r);return{k1neg:g,k1:l,k2neg:x,k2:d}}}},Le);export{sr as secp256k1};
