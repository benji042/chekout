import{bs as rt,bt as $t,bu as ht,bv as we,bw as ge,bx as Dt,by as Yt,bz as G,bA as St,bB as pe,bC as ye,bD as me,bE as Lt}from"./index-B3shc14o.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const It=BigInt(0),xt=BigInt(1);function wt(r,e=""){if(typeof r!="boolean"){const o=e&&`"${e}"`;throw new Error(o+"expected boolean, got type="+typeof r)}return r}function W(r,e,o=""){const t=St(r),n=r==null?void 0:r.length,c=e!==void 0;if(!t||c&&n!==e){const s=o&&`"${o}" `,f=c?` of length ${e}`:"",d=t?`length=${n}`:`type=${typeof r}`;throw new Error(s+"expected Uint8Array"+f+", got "+d)}return r}function lt(r){const e=r.toString(16);return e.length&1?"0"+e:e}function zt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?It:BigInt("0x"+r)}function pt(r){return zt(rt(r))}function Gt(r){return $t(r),zt(rt(Uint8Array.from(r).reverse()))}function At(r,e){return ht(r.toString(16).padStart(e*2,"0"))}function Mt(r,e){return At(r,e).reverse()}function P(r,e,o){let t;if(typeof e=="string")try{t=ht(e)}catch(n){throw new Error(r+" must be hex string or Uint8Array, cause: "+n)}else if(St(e))t=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");return t.length,t}const yt=r=>typeof r=="bigint"&&It<=r;function be(r,e,o){return yt(r)&&yt(e)&&yt(o)&&e<=r&&r<o}function Ee(r,e,o,t){if(!be(e,o,t))throw new Error("expected valid "+r+": "+o+" <= n < "+t+", got "+e)}function Xt(r){let e;for(e=0;r>It;r>>=xt,e+=1);return e}const st=r=>(xt<<BigInt(r))-xt;function Be(r,e,o){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof o!="function")throw new Error("hmacFn must be a function");const t=i=>new Uint8Array(i),n=i=>Uint8Array.of(i);let c=t(r),s=t(r),f=0;const d=()=>{c.fill(1),s.fill(0),f=0},g=(...i)=>o(s,c,...i),y=(i=t(0))=>{s=g(n(0),i),c=g(),i.length!==0&&(s=g(n(1),i),c=g())},x=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let i=0;const h=[];for(;i<e;){c=g();const R=c.slice();h.push(R),i+=c.length}return G(...h)};return(i,h)=>{d(),y(i);let R;for(;!(R=h(x()));)y();return d(),R}}function Nt(r,e,o={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function t(n,c,s){const f=r[n];if(s&&f===void 0)return;const d=typeof f;if(d!==c||f===null)throw new Error(`param "${n}" is invalid: expected ${c}, got ${d}`)}Object.entries(e).forEach(([n,c])=>t(n,c,!1)),Object.entries(o).forEach(([n,c])=>t(n,c,!0))}function Ut(r){const e=new WeakMap;return(o,...t)=>{const n=e.get(o);if(n!==void 0)return n;const c=r(o,...t);return e.set(o,c),c}}class Wt extends pe{constructor(e,o){super(),this.finished=!1,this.destroyed=!1,Dt(e);const t=ye(o);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,c=new Uint8Array(n);c.set(t.length>n?e.create().update(t).digest():t);for(let s=0;s<c.length;s++)c[s]^=54;this.iHash.update(c),this.oHash=e.create();for(let s=0;s<c.length;s++)c[s]^=106;this.oHash.update(c),me(c)}update(e){return Lt(this),this.iHash.update(e),this}digestInto(e){Lt(this),$t(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:o,iHash:t,finished:n,destroyed:c,blockLen:s,outputLen:f}=this;return e=e,e.finished=n,e.destroyed=c,e.blockLen=s,e.outputLen=f,e.oHash=o._cloneInto(e.oHash),e.iHash=t._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Jt=(r,e,o)=>new Wt(r,e).update(o).digest();Jt.create=(r,e)=>new Wt(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const K=BigInt(0),q=BigInt(1),J=BigInt(2),_t=BigInt(3),Qt=BigInt(4),te=BigInt(5),ve=BigInt(7),ee=BigInt(8),xe=BigInt(9),re=BigInt(16);function j(r,e){const o=r%e;return o>=K?o:e+o}function C(r,e,o){let t=r;for(;e-- >K;)t*=t,t%=o;return t}function kt(r,e){if(r===K)throw new Error("invert: expected non-zero number");if(e<=K)throw new Error("invert: expected positive modulus, got "+e);let o=j(r,e),t=e,n=K,c=q;for(;o!==K;){const s=t/o,f=t%o,d=n-c*s;t=o,o=f,n=c,c=d}if(t!==q)throw new Error("invert: does not exist");return j(n,e)}function Ft(r,e,o){if(!r.eql(r.sqr(e),o))throw new Error("Cannot find square root")}function oe(r,e){const o=(r.ORDER+q)/Qt,t=r.pow(e,o);return Ft(r,t,e),t}function Re(r,e){const o=(r.ORDER-te)/ee,t=r.mul(e,J),n=r.pow(t,o),c=r.mul(e,n),s=r.mul(r.mul(c,J),n),f=r.mul(c,r.sub(s,r.ONE));return Ft(r,f,e),f}function Oe(r){const e=ct(r),o=ne(r),t=o(e,e.neg(e.ONE)),n=o(e,t),c=o(e,e.neg(t)),s=(r+ve)/re;return(f,d)=>{let g=f.pow(d,s),y=f.mul(g,t);const x=f.mul(g,n),i=f.mul(g,c),h=f.eql(f.sqr(y),d),R=f.eql(f.sqr(x),d);g=f.cmov(g,y,h),y=f.cmov(i,x,R);const O=f.eql(f.sqr(y),d),N=f.cmov(g,y,O);return Ft(f,N,d),N}}function ne(r){if(r<_t)throw new Error("sqrt is not defined for small field");let e=r-q,o=0;for(;e%J===K;)e/=J,o++;let t=J;const n=ct(r);for(;qt(n,t)===1;)if(t++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(o===1)return oe;let c=n.pow(t,e);const s=(e+q)/J;return function(f,d){if(f.is0(d))return d;if(qt(f,d)!==1)throw new Error("Cannot find square root");let g=o,y=f.mul(f.ONE,c),x=f.pow(d,e),i=f.pow(d,s);for(;!f.eql(x,f.ONE);){if(f.is0(x))return f.ZERO;let h=1,R=f.sqr(x);for(;!f.eql(R,f.ONE);)if(h++,R=f.sqr(R),h===g)throw new Error("Cannot find square root");const O=q<<BigInt(g-h-1),N=f.pow(y,O);g=h,y=f.sqr(N),x=f.mul(x,y),i=f.mul(i,N)}return i}}function Se(r){return r%Qt===_t?oe:r%ee===te?Re:r%re===xe?Oe(r):ne(r)}const Ie=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ae(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},o=Ie.reduce((t,n)=>(t[n]="function",t),e);return Nt(r,o),r}function Ne(r,e,o){if(o<K)throw new Error("invalid exponent, negatives unsupported");if(o===K)return r.ONE;if(o===q)return e;let t=r.ONE,n=e;for(;o>K;)o&q&&(t=r.mul(t,n)),n=r.sqr(n),o>>=q;return t}function ie(r,e,o=!1){const t=new Array(e.length).fill(o?r.ZERO:void 0),n=e.reduce((s,f,d)=>r.is0(f)?s:(t[d]=s,r.mul(s,f)),r.ONE),c=r.inv(n);return e.reduceRight((s,f,d)=>r.is0(f)?s:(t[d]=r.mul(s,t[d]),r.mul(s,f)),c),t}function qt(r,e){const o=(r.ORDER-q)/J,t=r.pow(e,o),n=r.eql(t,r.ONE),c=r.eql(t,r.ZERO),s=r.eql(t,r.neg(r.ONE));if(!n&&!c&&!s)throw new Error("invalid Legendre symbol result");return n?1:c?0:-1}function se(r,e){e!==void 0&&we(e);const o=e!==void 0?e:r.toString(2).length,t=Math.ceil(o/8);return{nBitLength:o,nByteLength:t}}function ct(r,e,o=!1,t={}){if(r<=K)throw new Error("invalid field: expected ORDER > 0, got "+r);let n,c,s=!1,f;if(typeof e=="object"&&e!=null){if(t.sqrt||o)throw new Error("cannot specify opts in two arguments");const i=e;i.BITS&&(n=i.BITS),i.sqrt&&(c=i.sqrt),typeof i.isLE=="boolean"&&(o=i.isLE),typeof i.modFromBytes=="boolean"&&(s=i.modFromBytes),f=i.allowedLengths}else typeof e=="number"&&(n=e),t.sqrt&&(c=t.sqrt);const{nBitLength:d,nByteLength:g}=se(r,n);if(g>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let y;const x=Object.freeze({ORDER:r,isLE:o,BITS:d,BYTES:g,MASK:st(d),ZERO:K,ONE:q,allowedLengths:f,create:i=>j(i,r),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return K<=i&&i<r},is0:i=>i===K,isValidNot0:i=>!x.is0(i)&&x.isValid(i),isOdd:i=>(i&q)===q,neg:i=>j(-i,r),eql:(i,h)=>i===h,sqr:i=>j(i*i,r),add:(i,h)=>j(i+h,r),sub:(i,h)=>j(i-h,r),mul:(i,h)=>j(i*h,r),pow:(i,h)=>Ne(x,i,h),div:(i,h)=>j(i*kt(h,r),r),sqrN:i=>i*i,addN:(i,h)=>i+h,subN:(i,h)=>i-h,mulN:(i,h)=>i*h,inv:i=>kt(i,r),sqrt:c||(i=>(y||(y=Se(r)),y(x,i))),toBytes:i=>o?Mt(i,g):At(i,g),fromBytes:(i,h=!0)=>{if(f){if(!f.includes(i.length)||i.length>g)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+i.length);const O=new Uint8Array(g);O.set(i,o?0:O.length-i.length),i=O}if(i.length!==g)throw new Error("Field.fromBytes: expected "+g+" bytes, got "+i.length);let R=o?Gt(i):pt(i);if(s&&(R=j(R,r)),!h&&!x.isValid(R))throw new Error("invalid field element: outside of range 0..ORDER");return R},invertBatch:i=>ie(x,i),cmov:(i,h,R)=>R?h:i});return Object.freeze(x)}function ce(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function fe(r){const e=ce(r);return e+Math.ceil(e/2)}function Fe(r,e,o=!1){const t=r.length,n=ce(e),c=fe(e);if(t<16||t<c||t>1024)throw new Error("expected "+c+"-1024 bytes of input, got "+t);const s=o?Gt(r):pt(r),f=j(s,e-q)+q;return o?Mt(f,n):At(f,n)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nt=BigInt(0),_=BigInt(1);function gt(r,e){const o=e.negate();return r?o:e}function mt(r,e){const o=ie(r.Fp,e.map(t=>t.Z));return e.map((t,n)=>r.fromAffine(t.toAffine(o[n])))}function ae(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function bt(r,e){ae(r,e);const o=Math.ceil(e/r)+1,t=2**(r-1),n=2**r,c=st(r),s=BigInt(r);return{windows:o,windowSize:t,mask:c,maxNumber:n,shiftBy:s}}function Pt(r,e,o){const{windowSize:t,mask:n,maxNumber:c,shiftBy:s}=o;let f=Number(r&n),d=r>>s;f>t&&(f-=c,d+=_);const g=e*t,y=g+Math.abs(f)-1,x=f===0,i=f<0,h=e%2!==0;return{nextN:d,offset:y,isZero:x,isNeg:i,isNegF:h,offsetF:g}}function Ze(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((o,t)=>{if(!(o instanceof e))throw new Error("invalid point at index "+t)})}function He(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((o,t)=>{if(!e.isValid(o))throw new Error("invalid scalar at index "+t)})}const Et=new WeakMap,ue=new WeakMap;function Bt(r){return ue.get(r)||1}function Kt(r){if(r!==nt)throw new Error("invalid wNAF")}class Ve{constructor(e,o){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=o}_unsafeLadder(e,o,t=this.ZERO){let n=e;for(;o>nt;)o&_&&(t=t.add(n)),n=n.double(),o>>=_;return t}precomputeWindow(e,o){const{windows:t,windowSize:n}=bt(o,this.bits),c=[];let s=e,f=s;for(let d=0;d<t;d++){f=s,c.push(f);for(let g=1;g<n;g++)f=f.add(s),c.push(f);s=f.double()}return c}wNAF(e,o,t){if(!this.Fn.isValid(t))throw new Error("invalid scalar");let n=this.ZERO,c=this.BASE;const s=bt(e,this.bits);for(let f=0;f<s.windows;f++){const{nextN:d,offset:g,isZero:y,isNeg:x,isNegF:i,offsetF:h}=Pt(t,f,s);t=d,y?c=c.add(gt(i,o[h])):n=n.add(gt(x,o[g]))}return Kt(t),{p:n,f:c}}wNAFUnsafe(e,o,t,n=this.ZERO){const c=bt(e,this.bits);for(let s=0;s<c.windows&&t!==nt;s++){const{nextN:f,offset:d,isZero:g,isNeg:y}=Pt(t,s,c);if(t=f,!g){const x=o[d];n=n.add(y?x.negate():x)}}return Kt(t),n}getPrecomputes(e,o,t){let n=Et.get(o);return n||(n=this.precomputeWindow(o,e),e!==1&&(typeof t=="function"&&(n=t(n)),Et.set(o,n))),n}cached(e,o,t){const n=Bt(e);return this.wNAF(n,this.getPrecomputes(n,e,t),o)}unsafe(e,o,t,n){const c=Bt(e);return c===1?this._unsafeLadder(e,o,n):this.wNAFUnsafe(c,this.getPrecomputes(c,e,t),o,n)}createCache(e,o){ae(o,this.bits),ue.set(e,o),Et.delete(e)}hasCache(e){return Bt(e)!==1}}function Le(r,e,o,t){let n=e,c=r.ZERO,s=r.ZERO;for(;o>nt||t>nt;)o&_&&(c=c.add(n)),t&_&&(s=s.add(n)),n=n.double(),o>>=_,t>>=_;return{p1:c,p2:s}}function Ue(r,e,o,t){Ze(o,r),He(t,e);const n=o.length,c=t.length;if(n!==c)throw new Error("arrays of points and scalars must have equal length");const s=r.ZERO,f=Xt(BigInt(n));let d=1;f>12?d=f-3:f>4?d=f-2:f>0&&(d=2);const g=st(d),y=new Array(Number(g)+1).fill(s),x=Math.floor((e.BITS-1)/d)*d;let i=s;for(let h=x;h>=0;h-=d){y.fill(s);for(let O=0;O<c;O++){const N=t[O],$=Number(N>>BigInt(h)&g);y[$]=y[$].add(o[O])}let R=s;for(let O=y.length-1,N=s;O>0;O--)N=N.add(y[O]),R=R.add(N);if(i=i.add(R),h!==0)for(let O=0;O<d;O++)i=i.double()}return i}function Ct(r,e,o){if(e){if(e.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Ae(e),e}else return ct(r,{isLE:o})}function ke(r,e,o={},t){if(t===void 0&&(t=r==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${r} CURVE object`);for(const f of["p","n","h"]){const d=e[f];if(!(typeof d=="bigint"&&d>nt))throw new Error(`CURVE.${f} must be positive bigint`)}const n=Ct(e.p,o.Fp,t),c=Ct(e.n,o.Fn,t),s=["Gx","Gy","a","b"];for(const f of s)if(!n.isValid(e[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:n,Fn:c}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jt=(r,e)=>(r+(r>=0?e:-e)/le)/e;function qe(r,e,o){const[[t,n],[c,s]]=e,f=jt(s*r,o),d=jt(-n*r,o);let g=r-f*t-d*c,y=-f*n-d*s;const x=g<Y,i=y<Y;x&&(g=-g),i&&(y=-y);const h=st(Math.ceil(Xt(o)/2))+ot;if(g<Y||g>=h||y<Y||y>=h)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:x,k1:g,k2neg:i,k2:y}}function Rt(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function vt(r,e){const o={};for(let t of Object.keys(e))o[t]=r[t]===void 0?e[t]:r[t];return wt(o.lowS,"lowS"),wt(o.prehash,"prehash"),o.format!==void 0&&Rt(o.format),o}class Pe extends Error{constructor(e=""){super(e)}}const D={Err:Pe,_tlv:{encode:(r,e)=>{const{Err:o}=D;if(r<0||r>256)throw new o("tlv.encode: wrong tag");if(e.length&1)throw new o("tlv.encode: unpadded data");const t=e.length/2,n=lt(t);if(n.length/2&128)throw new o("tlv.encode: long form length too big");const c=t>127?lt(n.length/2|128):"";return lt(r)+c+n+e},decode(r,e){const{Err:o}=D;let t=0;if(r<0||r>256)throw new o("tlv.encode: wrong tag");if(e.length<2||e[t++]!==r)throw new o("tlv.decode: wrong tlv");const n=e[t++],c=!!(n&128);let s=0;if(!c)s=n;else{const d=n&127;if(!d)throw new o("tlv.decode(long): indefinite length not supported");if(d>4)throw new o("tlv.decode(long): byte length is too big");const g=e.subarray(t,t+d);if(g.length!==d)throw new o("tlv.decode: length bytes not complete");if(g[0]===0)throw new o("tlv.decode(long): zero leftmost byte");for(const y of g)s=s<<8|y;if(t+=d,s<128)throw new o("tlv.decode(long): not minimal encoding")}const f=e.subarray(t,t+s);if(f.length!==s)throw new o("tlv.decode: wrong value length");return{v:f,l:e.subarray(t+s)}}},_int:{encode(r){const{Err:e}=D;if(r<Y)throw new e("integer: negative integers are not allowed");let o=lt(r);if(Number.parseInt(o[0],16)&8&&(o="00"+o),o.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return o},decode(r){const{Err:e}=D;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return pt(r)}},toSig(r){const{Err:e,_int:o,_tlv:t}=D,n=P("signature",r),{v:c,l:s}=t.decode(48,n);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:f,l:d}=t.decode(2,c),{v:g,l:y}=t.decode(2,d);if(y.length)throw new e("invalid signature: left bytes after parsing");return{r:o.decode(f),s:o.decode(g)}},hexFromSig(r){const{_tlv:e,_int:o}=D,t=e.encode(2,o.encode(r.r)),n=e.encode(2,o.encode(r.s)),c=t+n;return e.encode(48,c)}},Y=BigInt(0),ot=BigInt(1),le=BigInt(2),dt=BigInt(3),Ke=BigInt(4);function et(r,e){const{BYTES:o}=r;let t;if(typeof e=="bigint")t=e;else{let n=P("private key",e);try{t=r.fromBytes(n)}catch{throw new Error(`invalid private key: expected ui8a of size ${o}, got ${typeof e}`)}}if(!r.isValidNot0(t))throw new Error("invalid private key: out of range [1..N-1]");return t}function Ce(r,e={}){const o=ke("weierstrass",r,e),{Fp:t,Fn:n}=o;let c=o.CURVE;const{h:s,n:f}=c;Nt(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:d}=e;if(d&&(!t.is0(c.a)||typeof d.beta!="bigint"||!Array.isArray(d.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const g=he(t,n);function y(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function x(A,l,a){const{x:u,y:w}=l.toAffine(),m=t.toBytes(u);if(wt(a,"isCompressed"),a){y();const E=!t.isOdd(w);return G(de(E),m)}else return G(Uint8Array.of(4),m,t.toBytes(w))}function i(A){W(A,void 0,"Point");const{publicKey:l,publicKeyUncompressed:a}=g,u=A.length,w=A[0],m=A.subarray(1);if(u===l&&(w===2||w===3)){const E=t.fromBytes(m);if(!t.isValid(E))throw new Error("bad point: is not on curve, wrong x");const b=O(E);let p;try{p=t.sqrt(b)}catch(v){const U=v instanceof Error?": "+v.message:"";throw new Error("bad point: is not on curve, sqrt error"+U)}y();const B=t.isOdd(p);return(w&1)===1!==B&&(p=t.neg(p)),{x:E,y:p}}else if(u===a&&w===4){const E=t.BYTES,b=t.fromBytes(m.subarray(0,E)),p=t.fromBytes(m.subarray(E,E*2));if(!N(b,p))throw new Error("bad point: is not on curve");return{x:b,y:p}}else throw new Error(`bad point: got length ${u}, expected compressed=${l} or uncompressed=${a}`)}const h=e.toBytes||x,R=e.fromBytes||i;function O(A){const l=t.sqr(A),a=t.mul(l,A);return t.add(t.add(a,t.mul(A,c.a)),c.b)}function N(A,l){const a=t.sqr(l),u=O(A);return t.eql(a,u)}if(!N(c.Gx,c.Gy))throw new Error("bad curve params: generator point");const $=t.mul(t.pow(c.a,dt),Ke),it=t.mul(t.sqr(c.b),BigInt(27));if(t.is0(t.add($,it)))throw new Error("bad curve params: a or b");function L(A,l,a=!1){if(!t.isValid(l)||a&&t.is0(l))throw new Error(`bad point coordinate ${A}`);return l}function M(A){if(!(A instanceof S))throw new Error("ProjectivePoint expected")}function z(A){if(!d||!d.basises)throw new Error("no endo");return qe(A,d.basises,n.ORDER)}const Q=Ut((A,l)=>{const{X:a,Y:u,Z:w}=A;if(t.eql(w,t.ONE))return{x:a,y:u};const m=A.is0();l==null&&(l=m?t.ONE:t.inv(w));const E=t.mul(a,l),b=t.mul(u,l),p=t.mul(w,l);if(m)return{x:t.ZERO,y:t.ZERO};if(!t.eql(p,t.ONE))throw new Error("invZ was invalid");return{x:E,y:b}}),ft=Ut(A=>{if(A.is0()){if(e.allowInfinityPoint&&!t.is0(A.Y))return;throw new Error("bad point: ZERO")}const{x:l,y:a}=A.toAffine();if(!t.isValid(l)||!t.isValid(a))throw new Error("bad point: x or y not field elements");if(!N(l,a))throw new Error("bad point: equation left != right");if(!A.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function tt(A,l,a,u,w){return a=new S(t.mul(a.X,A),a.Y,a.Z),l=gt(u,l),a=gt(w,a),l.add(a)}class S{constructor(l,a,u){this.X=L("x",l),this.Y=L("y",a,!0),this.Z=L("z",u),Object.freeze(this)}static CURVE(){return c}static fromAffine(l){const{x:a,y:u}=l||{};if(!l||!t.isValid(a)||!t.isValid(u))throw new Error("invalid affine point");if(l instanceof S)throw new Error("projective point not allowed");return t.is0(a)&&t.is0(u)?S.ZERO:new S(a,u,t.ONE)}static fromBytes(l){const a=S.fromAffine(R(W(l,void 0,"point")));return a.assertValidity(),a}static fromHex(l){return S.fromBytes(P("pointHex",l))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(l=8,a=!0){return X.createCache(this,l),a||this.multiply(dt),this}assertValidity(){ft(this)}hasEvenY(){const{y:l}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(l)}equals(l){M(l);const{X:a,Y:u,Z:w}=this,{X:m,Y:E,Z:b}=l,p=t.eql(t.mul(a,b),t.mul(m,w)),B=t.eql(t.mul(u,b),t.mul(E,w));return p&&B}negate(){return new S(this.X,t.neg(this.Y),this.Z)}double(){const{a:l,b:a}=c,u=t.mul(a,dt),{X:w,Y:m,Z:E}=this;let b=t.ZERO,p=t.ZERO,B=t.ZERO,v=t.mul(w,w),U=t.mul(m,m),F=t.mul(E,E),I=t.mul(w,m);return I=t.add(I,I),B=t.mul(w,E),B=t.add(B,B),b=t.mul(l,B),p=t.mul(u,F),p=t.add(b,p),b=t.sub(U,p),p=t.add(U,p),p=t.mul(b,p),b=t.mul(I,b),B=t.mul(u,B),F=t.mul(l,F),I=t.sub(v,F),I=t.mul(l,I),I=t.add(I,B),B=t.add(v,v),v=t.add(B,v),v=t.add(v,F),v=t.mul(v,I),p=t.add(p,v),F=t.mul(m,E),F=t.add(F,F),v=t.mul(F,I),b=t.sub(b,v),B=t.mul(F,U),B=t.add(B,B),B=t.add(B,B),new S(b,p,B)}add(l){M(l);const{X:a,Y:u,Z:w}=this,{X:m,Y:E,Z:b}=l;let p=t.ZERO,B=t.ZERO,v=t.ZERO;const U=c.a,F=t.mul(c.b,dt);let I=t.mul(a,m),Z=t.mul(u,E),V=t.mul(w,b),T=t.add(a,u),H=t.add(m,E);T=t.mul(T,H),H=t.add(I,Z),T=t.sub(T,H),H=t.add(a,w);let k=t.add(m,b);return H=t.mul(H,k),k=t.add(I,V),H=t.sub(H,k),k=t.add(u,w),p=t.add(E,b),k=t.mul(k,p),p=t.add(Z,V),k=t.sub(k,p),v=t.mul(U,H),p=t.mul(F,V),v=t.add(p,v),p=t.sub(Z,v),v=t.add(Z,v),B=t.mul(p,v),Z=t.add(I,I),Z=t.add(Z,I),V=t.mul(U,V),H=t.mul(F,H),Z=t.add(Z,V),V=t.sub(I,V),V=t.mul(U,V),H=t.add(H,V),I=t.mul(Z,H),B=t.add(B,I),I=t.mul(k,H),p=t.mul(T,p),p=t.sub(p,I),I=t.mul(T,Z),v=t.mul(k,v),v=t.add(v,I),new S(p,B,v)}subtract(l){return this.add(l.negate())}is0(){return this.equals(S.ZERO)}multiply(l){const{endo:a}=e;if(!n.isValidNot0(l))throw new Error("invalid scalar: out of range");let u,w;const m=E=>X.cached(this,E,b=>mt(S,b));if(a){const{k1neg:E,k1:b,k2neg:p,k2:B}=z(l),{p:v,f:U}=m(b),{p:F,f:I}=m(B);w=U.add(I),u=tt(a.beta,v,F,E,p)}else{const{p:E,f:b}=m(l);u=E,w=b}return mt(S,[u,w])[0]}multiplyUnsafe(l){const{endo:a}=e,u=this;if(!n.isValid(l))throw new Error("invalid scalar: out of range");if(l===Y||u.is0())return S.ZERO;if(l===ot)return u;if(X.hasCache(this))return this.multiply(l);if(a){const{k1neg:w,k1:m,k2neg:E,k2:b}=z(l),{p1:p,p2:B}=Le(S,u,m,b);return tt(a.beta,p,B,w,E)}else return X.unsafe(u,l)}multiplyAndAddUnsafe(l,a,u){const w=this.multiplyUnsafe(a).add(l.multiplyUnsafe(u));return w.is0()?void 0:w}toAffine(l){return Q(this,l)}isTorsionFree(){const{isTorsionFree:l}=e;return s===ot?!0:l?l(S,this):X.unsafe(this,f).is0()}clearCofactor(){const{clearCofactor:l}=e;return s===ot?this:l?l(S,this):this.multiplyUnsafe(s)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}toBytes(l=!0){return wt(l,"isCompressed"),this.assertValidity(),h(S,this,l)}toHex(l=!0){return rt(this.toBytes(l))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(l=!0){return this.toBytes(l)}_setWindowSize(l){this.precompute(l)}static normalizeZ(l){return mt(S,l)}static msm(l,a){return Ue(S,n,l,a)}static fromPrivateKey(l){return S.BASE.multiply(et(n,l))}}S.BASE=new S(c.Gx,c.Gy,t.ONE),S.ZERO=new S(t.ZERO,t.ONE,t.ZERO),S.Fp=t,S.Fn=n;const at=n.BITS,X=new Ve(S,e.endo?Math.ceil(at/2):at);return S.BASE.precompute(8),S}function de(r){return Uint8Array.of(r?2:3)}function he(r,e){return{secretKey:e.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function je(r,e={}){const{Fn:o}=r,t=e.randomBytes||Yt,n=Object.assign(he(r.Fp,o),{seed:fe(o.ORDER)});function c(i){try{return!!et(o,i)}catch{return!1}}function s(i,h){const{publicKey:R,publicKeyUncompressed:O}=n;try{const N=i.length;return h===!0&&N!==R||h===!1&&N!==O?!1:!!r.fromBytes(i)}catch{return!1}}function f(i=t(n.seed)){return Fe(W(i,n.seed,"seed"),o.ORDER)}function d(i,h=!0){return r.BASE.multiply(et(o,i)).toBytes(h)}function g(i){const h=f(i);return{secretKey:h,publicKey:d(h)}}function y(i){if(typeof i=="bigint")return!1;if(i instanceof r)return!0;const{secretKey:h,publicKey:R,publicKeyUncompressed:O}=n;if(o.allowedLengths||h===R)return;const N=P("key",i).length;return N===R||N===O}function x(i,h,R=!0){if(y(i)===!0)throw new Error("first arg must be private key");if(y(h)===!1)throw new Error("second arg must be public key");const O=et(o,i);return r.fromHex(h).multiply(O).toBytes(R)}return Object.freeze({getPublicKey:d,getSharedSecret:x,keygen:g,Point:r,utils:{isValidSecretKey:c,isValidPublicKey:s,randomSecretKey:f,isValidPrivateKey:c,randomPrivateKey:f,normPrivateKeyToScalar:i=>et(o,i),precompute(i=8,h=r.BASE){return h.precompute(i,!1)}},lengths:n})}function Te(r,e,o={}){Dt(e),Nt(o,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const t=o.randomBytes||Yt,n=o.hmac||((a,...u)=>Jt(e,a,G(...u))),{Fp:c,Fn:s}=r,{ORDER:f,BITS:d}=s,{keygen:g,getPublicKey:y,getSharedSecret:x,utils:i,lengths:h}=je(r,o),R={prehash:!1,lowS:typeof o.lowS=="boolean"?o.lowS:!1,format:void 0,extraEntropy:!1},O="compact";function N(a){const u=f>>ot;return a>u}function $(a,u){if(!s.isValidNot0(u))throw new Error(`invalid signature ${a}: out of range 1..Point.Fn.ORDER`);return u}function it(a,u){Rt(u);const w=h.signature,m=u==="compact"?w:u==="recovered"?w+1:void 0;return W(a,m,`${u} signature`)}class L{constructor(u,w,m){this.r=$("r",u),this.s=$("s",w),m!=null&&(this.recovery=m),Object.freeze(this)}static fromBytes(u,w=O){it(u,w);let m;if(w==="der"){const{r:B,s:v}=D.toSig(W(u));return new L(B,v)}w==="recovered"&&(m=u[0],w="compact",u=u.subarray(1));const E=s.BYTES,b=u.subarray(0,E),p=u.subarray(E,E*2);return new L(s.fromBytes(b),s.fromBytes(p),m)}static fromHex(u,w){return this.fromBytes(ht(u),w)}addRecoveryBit(u){return new L(this.r,this.s,u)}recoverPublicKey(u){const w=c.ORDER,{r:m,s:E,recovery:b}=this;if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");if(f*le<w&&b>1)throw new Error("recovery id is ambiguous for h>1 curve");const p=b===2||b===3?m+f:m;if(!c.isValid(p))throw new Error("recovery id 2 or 3 invalid");const B=c.toBytes(p),v=r.fromBytes(G(de((b&1)===0),B)),U=s.inv(p),F=z(P("msgHash",u)),I=s.create(-F*U),Z=s.create(E*U),V=r.BASE.multiplyUnsafe(I).add(v.multiplyUnsafe(Z));if(V.is0())throw new Error("point at infinify");return V.assertValidity(),V}hasHighS(){return N(this.s)}toBytes(u=O){if(Rt(u),u==="der")return ht(D.hexFromSig(this));const w=s.toBytes(this.r),m=s.toBytes(this.s);if(u==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return G(Uint8Array.of(this.recovery),w,m)}return G(w,m)}toHex(u){return rt(this.toBytes(u))}assertValidity(){}static fromCompact(u){return L.fromBytes(P("sig",u),"compact")}static fromDER(u){return L.fromBytes(P("sig",u),"der")}normalizeS(){return this.hasHighS()?new L(this.r,s.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return rt(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return rt(this.toBytes("compact"))}}const M=o.bits2int||function(a){if(a.length>8192)throw new Error("input is too large");const u=pt(a),w=a.length*8-d;return w>0?u>>BigInt(w):u},z=o.bits2int_modN||function(a){return s.create(M(a))},Q=st(d);function ft(a){return Ee("num < 2^"+d,a,Y,Q),s.toBytes(a)}function tt(a,u){return W(a,void 0,"message"),u?W(e(a),void 0,"prehashed message"):a}function S(a,u,w){if(["recovered","canonical"].some(Z=>Z in w))throw new Error("sign() legacy options not supported");const{lowS:m,prehash:E,extraEntropy:b}=vt(w,R);a=tt(a,E);const p=z(a),B=et(s,u),v=[ft(B),ft(p)];if(b!=null&&b!==!1){const Z=b===!0?t(h.secretKey):b;v.push(P("extraEntropy",Z))}const U=G(...v),F=p;function I(Z){const V=M(Z);if(!s.isValidNot0(V))return;const T=s.inv(V),H=r.BASE.multiply(V).toAffine(),k=s.create(H.x);if(k===Y)return;const ut=s.create(T*s.create(F+k*B));if(ut===Y)return;let Ht=(H.x===k?0:2)|Number(H.y&ot),Vt=ut;return m&&N(ut)&&(Vt=s.neg(ut),Ht^=1),new L(k,Vt,Ht)}return{seed:U,k2sig:I}}function at(a,u,w={}){a=P("message",a);const{seed:m,k2sig:E}=S(a,u,w);return Be(e.outputLen,s.BYTES,n)(m,E)}function X(a){let u;const w=typeof a=="string"||St(a),m=!w&&a!==null&&typeof a=="object"&&typeof a.r=="bigint"&&typeof a.s=="bigint";if(!w&&!m)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(m)u=new L(a.r,a.s);else if(w){try{u=L.fromBytes(P("sig",a),"der")}catch(E){if(!(E instanceof D.Err))throw E}if(!u)try{u=L.fromBytes(P("sig",a),"compact")}catch{return!1}}return u||!1}function A(a,u,w,m={}){const{lowS:E,prehash:b,format:p}=vt(m,R);if(w=P("publicKey",w),u=tt(P("message",u),b),"strict"in m)throw new Error("options.strict was renamed to lowS");const B=p===void 0?X(a):L.fromBytes(P("sig",a),p);if(B===!1)return!1;try{const v=r.fromBytes(w);if(E&&B.hasHighS())return!1;const{r:U,s:F}=B,I=z(u),Z=s.inv(F),V=s.create(I*Z),T=s.create(U*Z),H=r.BASE.multiplyUnsafe(V).add(v.multiplyUnsafe(T));return H.is0()?!1:s.create(H.x)===U}catch{return!1}}function l(a,u,w={}){const{prehash:m}=vt(w,R);return u=tt(u,m),L.fromBytes(a,"recovered").recoverPublicKey(u).toBytes()}return Object.freeze({keygen:g,getPublicKey:y,getSharedSecret:x,utils:i,lengths:h,Point:r,sign:at,verify:A,recoverPublicKey:l,Signature:L,hash:e})}function $e(r){const e={a:r.a,b:r.b,p:r.Fp.ORDER,n:r.n,h:r.h,Gx:r.Gx,Gy:r.Gy},o=r.Fp;let t=r.allowedPrivateKeyLengths?Array.from(new Set(r.allowedPrivateKeyLengths.map(s=>Math.ceil(s/2)))):void 0;const n=ct(e.n,{BITS:r.nBitLength,allowedLengths:t,modFromBytes:r.wrapPrivateKey}),c={Fp:o,Fn:n,allowInfinityPoint:r.allowInfinityPoint,endo:r.endo,isTorsionFree:r.isTorsionFree,clearCofactor:r.clearCofactor,fromBytes:r.fromBytes,toBytes:r.toBytes};return{CURVE:e,curveOpts:c}}function De(r){const{CURVE:e,curveOpts:o}=$e(r),t={hmac:r.hmac,randomBytes:r.randomBytes,lowS:r.lowS,bits2int:r.bits2int,bits2int_modN:r.bits2int_modN};return{CURVE:e,curveOpts:o,hash:r.hash,ecdsaOpts:t}}function Ye(r,e){const o=e.Point;return Object.assign({},e,{ProjectivePoint:o,CURVE:Object.assign({},r,se(o.Fn.ORDER,o.Fn.BITS))})}function ze(r){const{CURVE:e,curveOpts:o,hash:t,ecdsaOpts:n}=De(r),c=Ce(e,o),s=Te(c,t,n);return Ye(r,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ge(r,e){const o=t=>ze({...r,hash:t});return{...o(e),create:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Me={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Tt=BigInt(2);function Xe(r){const e=Zt.p,o=BigInt(3),t=BigInt(6),n=BigInt(11),c=BigInt(22),s=BigInt(23),f=BigInt(44),d=BigInt(88),g=r*r*r%e,y=g*g*r%e,x=C(y,o,e)*y%e,i=C(x,o,e)*y%e,h=C(i,Tt,e)*g%e,R=C(h,n,e)*h%e,O=C(R,c,e)*R%e,N=C(O,f,e)*O%e,$=C(N,d,e)*N%e,it=C($,f,e)*O%e,L=C(it,o,e)*y%e,M=C(L,s,e)*R%e,z=C(M,t,e)*g%e,Q=C(z,Tt,e);if(!Ot.eql(Ot.sqr(Q),r))throw new Error("Cannot find square root");return Q}const Ot=ct(Zt.p,{sqrt:Xe}),Je=Ge({...Zt,Fp:Ot,lowS:!0,endo:Me},ge);export{Je as secp256k1};
