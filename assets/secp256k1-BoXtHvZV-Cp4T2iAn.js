import{bh as rt,bi as jt,bj as ht,bk as we,bl as ge,bm as Yt,bn as Dt,bo as G,bp as St,bq as pe,br as ye,bs as me,bt as kt}from"./index-d4DvafWv.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const It=BigInt(0),xt=BigInt(1);function wt(r,e=""){if(typeof r!="boolean"){const o=e&&`"${e}"`;throw new Error(o+"expected boolean, got type="+typeof r)}return r}function W(r,e,o=""){const t=St(r),n=r==null?void 0:r.length,c=e!==void 0;if(!t||c&&n!==e){const s=o&&`"${o}" `,f=c?` of length ${e}`:"",d=t?`length=${n}`:`type=${typeof r}`;throw new Error(s+"expected Uint8Array"+f+", got "+d)}return r}function lt(r){const e=r.toString(16);return e.length&1?"0"+e:e}function zt(r){if(typeof r!="string")throw new Error("hex string expected, got "+typeof r);return r===""?It:BigInt("0x"+r)}function pt(r){return zt(rt(r))}function Gt(r){return jt(r),zt(rt(Uint8Array.from(r).reverse()))}function Nt(r,e){return ht(r.toString(16).padStart(e*2,"0"))}function Xt(r,e){return Nt(r,e).reverse()}function K(r,e,o){let t;if(typeof e=="string")try{t=ht(e)}catch(n){throw new Error(r+" must be hex string or Uint8Array, cause: "+n)}else if(St(e))t=Uint8Array.from(e);else throw new Error(r+" must be hex string or Uint8Array");return t.length,t}const yt=r=>typeof r=="bigint"&&It<=r;function be(r,e,o){return yt(r)&&yt(e)&&yt(o)&&e<=r&&r<o}function Ee(r,e,o,t){if(!be(e,o,t))throw new Error("expected valid "+r+": "+o+" <= n < "+t+", got "+e)}function Mt(r){let e;for(e=0;r>It;r>>=xt,e+=1);return e}const st=r=>(xt<<BigInt(r))-xt;function Be(r,e,o){if(typeof r!="number"||r<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof o!="function")throw new Error("hmacFn must be a function");const t=i=>new Uint8Array(i),n=i=>Uint8Array.of(i);let c=t(r),s=t(r),f=0;const d=()=>{c.fill(1),s.fill(0),f=0},g=(...i)=>o(s,c,...i),y=(i=t(0))=>{s=g(n(0),i),c=g(),i.length!==0&&(s=g(n(1),i),c=g())},x=()=>{if(f++>=1e3)throw new Error("drbg: tried 1000 values");let i=0;const h=[];for(;i<e;){c=g();const O=c.slice();h.push(O),i+=c.length}return G(...h)};return(i,h)=>{d(),y(i);let O;for(;!(O=h(x()));)y();return d(),O}}function Ft(r,e,o={}){if(!r||typeof r!="object")throw new Error("expected valid options object");function t(n,c,s){const f=r[n];if(s&&f===void 0)return;const d=typeof f;if(d!==c||f===null)throw new Error(`param "${n}" is invalid: expected ${c}, got ${d}`)}Object.entries(e).forEach(([n,c])=>t(n,c,!1)),Object.entries(o).forEach(([n,c])=>t(n,c,!0))}function Lt(r){const e=new WeakMap;return(o,...t)=>{const n=e.get(o);if(n!==void 0)return n;const c=r(o,...t);return e.set(o,c),c}}class Wt extends pe{constructor(e,o){super(),this.finished=!1,this.destroyed=!1,Yt(e);const t=ye(o);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,c=new Uint8Array(n);c.set(t.length>n?e.create().update(t).digest():t);for(let s=0;s<c.length;s++)c[s]^=54;this.iHash.update(c),this.oHash=e.create();for(let s=0;s<c.length;s++)c[s]^=106;this.oHash.update(c),me(c)}update(e){return kt(this),this.iHash.update(e),this}digestInto(e){kt(this),jt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:o,iHash:t,finished:n,destroyed:c,blockLen:s,outputLen:f}=this;return e=e,e.finished=n,e.destroyed=c,e.blockLen=s,e.outputLen=f,e.oHash=o._cloneInto(e.oHash),e.iHash=t._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Jt=(r,e,o)=>new Wt(r,e).update(o).digest();Jt.create=(r,e)=>new Wt(r,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const P=BigInt(0),q=BigInt(1),J=BigInt(2),Qt=BigInt(3),_t=BigInt(4),te=BigInt(5),ve=BigInt(7),ee=BigInt(8),xe=BigInt(9),re=BigInt(16);function C(r,e){const o=r%e;return o>=P?o:e+o}function $(r,e,o){let t=r;for(;e-- >P;)t*=t,t%=o;return t}function Ut(r,e){if(r===P)throw new Error("invert: expected non-zero number");if(e<=P)throw new Error("invert: expected positive modulus, got "+e);let o=C(r,e),t=e,n=P,c=q;for(;o!==P;){const s=t/o,f=t%o,d=n-c*s;t=o,o=f,n=c,c=d}if(t!==q)throw new Error("invert: does not exist");return C(n,e)}function Zt(r,e,o){if(!r.eql(r.sqr(e),o))throw new Error("Cannot find square root")}function oe(r,e){const o=(r.ORDER+q)/_t,t=r.pow(e,o);return Zt(r,t,e),t}function Oe(r,e){const o=(r.ORDER-te)/ee,t=r.mul(e,J),n=r.pow(t,o),c=r.mul(e,n),s=r.mul(r.mul(c,J),n),f=r.mul(c,r.sub(s,r.ONE));return Zt(r,f,e),f}function Re(r){const e=ct(r),o=ne(r),t=o(e,e.neg(e.ONE)),n=o(e,t),c=o(e,e.neg(t)),s=(r+ve)/re;return(f,d)=>{let g=f.pow(d,s),y=f.mul(g,t);const x=f.mul(g,n),i=f.mul(g,c),h=f.eql(f.sqr(y),d),O=f.eql(f.sqr(x),d);g=f.cmov(g,y,h),y=f.cmov(i,x,O);const R=f.eql(f.sqr(y),d),F=f.cmov(g,y,R);return Zt(f,F,d),F}}function ne(r){if(r<Qt)throw new Error("sqrt is not defined for small field");let e=r-q,o=0;for(;e%J===P;)e/=J,o++;let t=J;const n=ct(r);for(;qt(n,t)===1;)if(t++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(o===1)return oe;let c=n.pow(t,e);const s=(e+q)/J;return function(f,d){if(f.is0(d))return d;if(qt(f,d)!==1)throw new Error("Cannot find square root");let g=o,y=f.mul(f.ONE,c),x=f.pow(d,e),i=f.pow(d,s);for(;!f.eql(x,f.ONE);){if(f.is0(x))return f.ZERO;let h=1,O=f.sqr(x);for(;!f.eql(O,f.ONE);)if(h++,O=f.sqr(O),h===g)throw new Error("Cannot find square root");const R=q<<BigInt(g-h-1),F=f.pow(y,R);g=h,y=f.sqr(F),x=f.mul(x,y),i=f.mul(i,F)}return i}}function Se(r){return r%_t===Qt?oe:r%ee===te?Oe:r%re===xe?Re(r):ne(r)}const Ie=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ne(r){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},o=Ie.reduce((t,n)=>(t[n]="function",t),e);return Ft(r,o),r}function Fe(r,e,o){if(o<P)throw new Error("invalid exponent, negatives unsupported");if(o===P)return r.ONE;if(o===q)return e;let t=r.ONE,n=e;for(;o>P;)o&q&&(t=r.mul(t,n)),n=r.sqr(n),o>>=q;return t}function ie(r,e,o=!1){const t=new Array(e.length).fill(o?r.ZERO:void 0),n=e.reduce((s,f,d)=>r.is0(f)?s:(t[d]=s,r.mul(s,f)),r.ONE),c=r.inv(n);return e.reduceRight((s,f,d)=>r.is0(f)?s:(t[d]=r.mul(s,t[d]),r.mul(s,f)),c),t}function qt(r,e){const o=(r.ORDER-q)/J,t=r.pow(e,o),n=r.eql(t,r.ONE),c=r.eql(t,r.ZERO),s=r.eql(t,r.neg(r.ONE));if(!n&&!c&&!s)throw new Error("invalid Legendre symbol result");return n?1:c?0:-1}function se(r,e){e!==void 0&&we(e);const o=e!==void 0?e:r.toString(2).length,t=Math.ceil(o/8);return{nBitLength:o,nByteLength:t}}function ct(r,e,o=!1,t={}){if(r<=P)throw new Error("invalid field: expected ORDER > 0, got "+r);let n,c,s=!1,f;if(typeof e=="object"&&e!=null){if(t.sqrt||o)throw new Error("cannot specify opts in two arguments");const i=e;i.BITS&&(n=i.BITS),i.sqrt&&(c=i.sqrt),typeof i.isLE=="boolean"&&(o=i.isLE),typeof i.modFromBytes=="boolean"&&(s=i.modFromBytes),f=i.allowedLengths}else typeof e=="number"&&(n=e),t.sqrt&&(c=t.sqrt);const{nBitLength:d,nByteLength:g}=se(r,n);if(g>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let y;const x=Object.freeze({ORDER:r,isLE:o,BITS:d,BYTES:g,MASK:st(d),ZERO:P,ONE:q,allowedLengths:f,create:i=>C(i,r),isValid:i=>{if(typeof i!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof i);return P<=i&&i<r},is0:i=>i===P,isValidNot0:i=>!x.is0(i)&&x.isValid(i),isOdd:i=>(i&q)===q,neg:i=>C(-i,r),eql:(i,h)=>i===h,sqr:i=>C(i*i,r),add:(i,h)=>C(i+h,r),sub:(i,h)=>C(i-h,r),mul:(i,h)=>C(i*h,r),pow:(i,h)=>Fe(x,i,h),div:(i,h)=>C(i*Ut(h,r),r),sqrN:i=>i*i,addN:(i,h)=>i+h,subN:(i,h)=>i-h,mulN:(i,h)=>i*h,inv:i=>Ut(i,r),sqrt:c||(i=>(y||(y=Se(r)),y(x,i))),toBytes:i=>o?Xt(i,g):Nt(i,g),fromBytes:(i,h=!0)=>{if(f){if(!f.includes(i.length)||i.length>g)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+i.length);const R=new Uint8Array(g);R.set(i,o?0:R.length-i.length),i=R}if(i.length!==g)throw new Error("Field.fromBytes: expected "+g+" bytes, got "+i.length);let O=o?Gt(i):pt(i);if(s&&(O=C(O,r)),!h&&!x.isValid(O))throw new Error("invalid field element: outside of range 0..ORDER");return O},invertBatch:i=>ie(x,i),cmov:(i,h,O)=>O?h:i});return Object.freeze(x)}function ce(r){if(typeof r!="bigint")throw new Error("field order must be bigint");const e=r.toString(2).length;return Math.ceil(e/8)}function fe(r){const e=ce(r);return e+Math.ceil(e/2)}function Ze(r,e,o=!1){const t=r.length,n=ce(e),c=fe(e);if(t<16||t<c||t>1024)throw new Error("expected "+c+"-1024 bytes of input, got "+t);const s=o?Gt(r):pt(r),f=C(s,e-q)+q;return o?Xt(f,n):Nt(f,n)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nt=BigInt(0),Q=BigInt(1);function gt(r,e){const o=e.negate();return r?o:e}function mt(r,e){const o=ie(r.Fp,e.map(t=>t.Z));return e.map((t,n)=>r.fromAffine(t.toAffine(o[n])))}function ae(r,e){if(!Number.isSafeInteger(r)||r<=0||r>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+r)}function bt(r,e){ae(r,e);const o=Math.ceil(e/r)+1,t=2**(r-1),n=2**r,c=st(r),s=BigInt(r);return{windows:o,windowSize:t,mask:c,maxNumber:n,shiftBy:s}}function Kt(r,e,o){const{windowSize:t,mask:n,maxNumber:c,shiftBy:s}=o;let f=Number(r&n),d=r>>s;f>t&&(f-=c,d+=Q);const g=e*t,y=g+Math.abs(f)-1,x=f===0,i=f<0,h=e%2!==0;return{nextN:d,offset:y,isZero:x,isNeg:i,isNegF:h,offsetF:g}}function Ae(r,e){if(!Array.isArray(r))throw new Error("array expected");r.forEach((o,t)=>{if(!(o instanceof e))throw new Error("invalid point at index "+t)})}function He(r,e){if(!Array.isArray(r))throw new Error("array of scalars expected");r.forEach((o,t)=>{if(!e.isValid(o))throw new Error("invalid scalar at index "+t)})}const Et=new WeakMap,ue=new WeakMap;function Bt(r){return ue.get(r)||1}function Pt(r){if(r!==nt)throw new Error("invalid wNAF")}class Ve{constructor(e,o){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=o}_unsafeLadder(e,o,t=this.ZERO){let n=e;for(;o>nt;)o&Q&&(t=t.add(n)),n=n.double(),o>>=Q;return t}precomputeWindow(e,o){const{windows:t,windowSize:n}=bt(o,this.bits),c=[];let s=e,f=s;for(let d=0;d<t;d++){f=s,c.push(f);for(let g=1;g<n;g++)f=f.add(s),c.push(f);s=f.double()}return c}wNAF(e,o,t){if(!this.Fn.isValid(t))throw new Error("invalid scalar");let n=this.ZERO,c=this.BASE;const s=bt(e,this.bits);for(let f=0;f<s.windows;f++){const{nextN:d,offset:g,isZero:y,isNeg:x,isNegF:i,offsetF:h}=Kt(t,f,s);t=d,y?c=c.add(gt(i,o[h])):n=n.add(gt(x,o[g]))}return Pt(t),{p:n,f:c}}wNAFUnsafe(e,o,t,n=this.ZERO){const c=bt(e,this.bits);for(let s=0;s<c.windows&&t!==nt;s++){const{nextN:f,offset:d,isZero:g,isNeg:y}=Kt(t,s,c);if(t=f,!g){const x=o[d];n=n.add(y?x.negate():x)}}return Pt(t),n}getPrecomputes(e,o,t){let n=Et.get(o);return n||(n=this.precomputeWindow(o,e),e!==1&&(typeof t=="function"&&(n=t(n)),Et.set(o,n))),n}cached(e,o,t){const n=Bt(e);return this.wNAF(n,this.getPrecomputes(n,e,t),o)}unsafe(e,o,t,n){const c=Bt(e);return c===1?this._unsafeLadder(e,o,n):this.wNAFUnsafe(c,this.getPrecomputes(c,e,t),o,n)}createCache(e,o){ae(o,this.bits),ue.set(e,o),Et.delete(e)}hasCache(e){return Bt(e)!==1}}function ke(r,e,o,t){let n=e,c=r.ZERO,s=r.ZERO;for(;o>nt||t>nt;)o&Q&&(c=c.add(n)),t&Q&&(s=s.add(n)),n=n.double(),o>>=Q,t>>=Q;return{p1:c,p2:s}}function Le(r,e,o,t){Ae(o,r),He(t,e);const n=o.length,c=t.length;if(n!==c)throw new Error("arrays of points and scalars must have equal length");const s=r.ZERO,f=Mt(BigInt(n));let d=1;f>12?d=f-3:f>4?d=f-2:f>0&&(d=2);const g=st(d),y=new Array(Number(g)+1).fill(s),x=Math.floor((e.BITS-1)/d)*d;let i=s;for(let h=x;h>=0;h-=d){y.fill(s);for(let R=0;R<c;R++){const F=t[R],j=Number(F>>BigInt(h)&g);y[j]=y[j].add(o[R])}let O=s;for(let R=y.length-1,F=s;R>0;R--)F=F.add(y[R]),O=O.add(F);if(i=i.add(O),h!==0)for(let R=0;R<d;R++)i=i.double()}return i}function $t(r,e,o){if(e){if(e.ORDER!==r)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Ne(e),e}else return ct(r,{isLE:o})}function Ue(r,e,o={},t){if(t===void 0&&(t=r==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${r} CURVE object`);for(const f of["p","n","h"]){const d=e[f];if(!(typeof d=="bigint"&&d>nt))throw new Error(`CURVE.${f} must be positive bigint`)}const n=$t(e.p,o.Fp,t),c=$t(e.n,o.Fn,t),s=["Gx","Gy","a","b"];for(const f of s)if(!n.isValid(e[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:n,Fn:c}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ct=(r,e)=>(r+(r>=0?e:-e)/le)/e;function qe(r,e,o){const[[t,n],[c,s]]=e,f=Ct(s*r,o),d=Ct(-n*r,o);let g=r-f*t-d*c,y=-f*n-d*s;const x=g<D,i=y<D;x&&(g=-g),i&&(y=-y);const h=st(Math.ceil(Mt(o)/2))+ot;if(g<D||g>=h||y<D||y>=h)throw new Error("splitScalar (endomorphism): failed, k="+r);return{k1neg:x,k1:g,k2neg:i,k2:y}}function Ot(r){if(!["compact","recovered","der"].includes(r))throw new Error('Signature format must be "compact", "recovered", or "der"');return r}function vt(r,e){const o={};for(let t of Object.keys(e))o[t]=r[t]===void 0?e[t]:r[t];return wt(o.lowS,"lowS"),wt(o.prehash,"prehash"),o.format!==void 0&&Ot(o.format),o}class Ke extends Error{constructor(e=""){super(e)}}const Y={Err:Ke,_tlv:{encode:(r,e)=>{const{Err:o}=Y;if(r<0||r>256)throw new o("tlv.encode: wrong tag");if(e.length&1)throw new o("tlv.encode: unpadded data");const t=e.length/2,n=lt(t);if(n.length/2&128)throw new o("tlv.encode: long form length too big");const c=t>127?lt(n.length/2|128):"";return lt(r)+c+n+e},decode(r,e){const{Err:o}=Y;let t=0;if(r<0||r>256)throw new o("tlv.encode: wrong tag");if(e.length<2||e[t++]!==r)throw new o("tlv.decode: wrong tlv");const n=e[t++],c=!!(n&128);let s=0;if(!c)s=n;else{const d=n&127;if(!d)throw new o("tlv.decode(long): indefinite length not supported");if(d>4)throw new o("tlv.decode(long): byte length is too big");const g=e.subarray(t,t+d);if(g.length!==d)throw new o("tlv.decode: length bytes not complete");if(g[0]===0)throw new o("tlv.decode(long): zero leftmost byte");for(const y of g)s=s<<8|y;if(t+=d,s<128)throw new o("tlv.decode(long): not minimal encoding")}const f=e.subarray(t,t+s);if(f.length!==s)throw new o("tlv.decode: wrong value length");return{v:f,l:e.subarray(t+s)}}},_int:{encode(r){const{Err:e}=Y;if(r<D)throw new e("integer: negative integers are not allowed");let o=lt(r);if(Number.parseInt(o[0],16)&8&&(o="00"+o),o.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return o},decode(r){const{Err:e}=Y;if(r[0]&128)throw new e("invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return pt(r)}},toSig(r){const{Err:e,_int:o,_tlv:t}=Y,n=K("signature",r),{v:c,l:s}=t.decode(48,n);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:f,l:d}=t.decode(2,c),{v:g,l:y}=t.decode(2,d);if(y.length)throw new e("invalid signature: left bytes after parsing");return{r:o.decode(f),s:o.decode(g)}},hexFromSig(r){const{_tlv:e,_int:o}=Y,t=e.encode(2,o.encode(r.r)),n=e.encode(2,o.encode(r.s)),c=t+n;return e.encode(48,c)}},D=BigInt(0),ot=BigInt(1),le=BigInt(2),dt=BigInt(3),Pe=BigInt(4);function et(r,e){const{BYTES:o}=r;let t;if(typeof e=="bigint")t=e;else{let n=K("private key",e);try{t=r.fromBytes(n)}catch{throw new Error(`invalid private key: expected ui8a of size ${o}, got ${typeof e}`)}}if(!r.isValidNot0(t))throw new Error("invalid private key: out of range [1..N-1]");return t}function $e(r,e={}){const o=Ue("weierstrass",r,e),{Fp:t,Fn:n}=o;let c=o.CURVE;const{h:s,n:f}=c;Ft(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:d}=e;if(d&&(!t.is0(c.a)||typeof d.beta!="bigint"||!Array.isArray(d.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const g=he(t,n);function y(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function x(N,l,a){const{x:u,y:w}=l.toAffine(),m=t.toBytes(u);if(wt(a,"isCompressed"),a){y();const E=!t.isOdd(w);return G(de(E),m)}else return G(Uint8Array.of(4),m,t.toBytes(w))}function i(N){W(N,void 0,"Point");const{publicKey:l,publicKeyUncompressed:a}=g,u=N.length,w=N[0],m=N.subarray(1);if(u===l&&(w===2||w===3)){const E=t.fromBytes(m);if(!t.isValid(E))throw new Error("bad point: is not on curve, wrong x");const b=R(E);let p;try{p=t.sqrt(b)}catch(v){const L=v instanceof Error?": "+v.message:"";throw new Error("bad point: is not on curve, sqrt error"+L)}y();const B=t.isOdd(p);return(w&1)===1!==B&&(p=t.neg(p)),{x:E,y:p}}else if(u===a&&w===4){const E=t.BYTES,b=t.fromBytes(m.subarray(0,E)),p=t.fromBytes(m.subarray(E,E*2));if(!F(b,p))throw new Error("bad point: is not on curve");return{x:b,y:p}}else throw new Error(`bad point: got length ${u}, expected compressed=${l} or uncompressed=${a}`)}const h=e.toBytes||x,O=e.fromBytes||i;function R(N){const l=t.sqr(N),a=t.mul(l,N);return t.add(t.add(a,t.mul(N,c.a)),c.b)}function F(N,l){const a=t.sqr(l),u=R(N);return t.eql(a,u)}if(!F(c.Gx,c.Gy))throw new Error("bad curve params: generator point");const j=t.mul(t.pow(c.a,dt),Pe),it=t.mul(t.sqr(c.b),BigInt(27));if(t.is0(t.add(j,it)))throw new Error("bad curve params: a or b");function k(N,l,a=!1){if(!t.isValid(l)||a&&t.is0(l))throw new Error(`bad point coordinate ${N}`);return l}function X(N){if(!(N instanceof S))throw new Error("ProjectivePoint expected")}function z(N){if(!d||!d.basises)throw new Error("no endo");return qe(N,d.basises,n.ORDER)}const _=Lt((N,l)=>{const{X:a,Y:u,Z:w}=N;if(t.eql(w,t.ONE))return{x:a,y:u};const m=N.is0();l==null&&(l=m?t.ONE:t.inv(w));const E=t.mul(a,l),b=t.mul(u,l),p=t.mul(w,l);if(m)return{x:t.ZERO,y:t.ZERO};if(!t.eql(p,t.ONE))throw new Error("invZ was invalid");return{x:E,y:b}}),ft=Lt(N=>{if(N.is0()){if(e.allowInfinityPoint&&!t.is0(N.Y))return;throw new Error("bad point: ZERO")}const{x:l,y:a}=N.toAffine();if(!t.isValid(l)||!t.isValid(a))throw new Error("bad point: x or y not field elements");if(!F(l,a))throw new Error("bad point: equation left != right");if(!N.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function tt(N,l,a,u,w){return a=new S(t.mul(a.X,N),a.Y,a.Z),l=gt(u,l),a=gt(w,a),l.add(a)}class S{constructor(l,a,u){this.X=k("x",l),this.Y=k("y",a,!0),this.Z=k("z",u),Object.freeze(this)}static CURVE(){return c}static fromAffine(l){const{x:a,y:u}=l||{};if(!l||!t.isValid(a)||!t.isValid(u))throw new Error("invalid affine point");if(l instanceof S)throw new Error("projective point not allowed");return t.is0(a)&&t.is0(u)?S.ZERO:new S(a,u,t.ONE)}static fromBytes(l){const a=S.fromAffine(O(W(l,void 0,"point")));return a.assertValidity(),a}static fromHex(l){return S.fromBytes(K("pointHex",l))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(l=8,a=!0){return M.createCache(this,l),a||this.multiply(dt),this}assertValidity(){ft(this)}hasEvenY(){const{y:l}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(l)}equals(l){X(l);const{X:a,Y:u,Z:w}=this,{X:m,Y:E,Z:b}=l,p=t.eql(t.mul(a,b),t.mul(m,w)),B=t.eql(t.mul(u,b),t.mul(E,w));return p&&B}negate(){return new S(this.X,t.neg(this.Y),this.Z)}double(){const{a:l,b:a}=c,u=t.mul(a,dt),{X:w,Y:m,Z:E}=this;let b=t.ZERO,p=t.ZERO,B=t.ZERO,v=t.mul(w,w),L=t.mul(m,m),Z=t.mul(E,E),I=t.mul(w,m);return I=t.add(I,I),B=t.mul(w,E),B=t.add(B,B),b=t.mul(l,B),p=t.mul(u,Z),p=t.add(b,p),b=t.sub(L,p),p=t.add(L,p),p=t.mul(b,p),b=t.mul(I,b),B=t.mul(u,B),Z=t.mul(l,Z),I=t.sub(v,Z),I=t.mul(l,I),I=t.add(I,B),B=t.add(v,v),v=t.add(B,v),v=t.add(v,Z),v=t.mul(v,I),p=t.add(p,v),Z=t.mul(m,E),Z=t.add(Z,Z),v=t.mul(Z,I),b=t.sub(b,v),B=t.mul(Z,L),B=t.add(B,B),B=t.add(B,B),new S(b,p,B)}add(l){X(l);const{X:a,Y:u,Z:w}=this,{X:m,Y:E,Z:b}=l;let p=t.ZERO,B=t.ZERO,v=t.ZERO;const L=c.a,Z=t.mul(c.b,dt);let I=t.mul(a,m),A=t.mul(u,E),V=t.mul(w,b),T=t.add(a,u),H=t.add(m,E);T=t.mul(T,H),H=t.add(I,A),T=t.sub(T,H),H=t.add(a,w);let U=t.add(m,b);return H=t.mul(H,U),U=t.add(I,V),H=t.sub(H,U),U=t.add(u,w),p=t.add(E,b),U=t.mul(U,p),p=t.add(A,V),U=t.sub(U,p),v=t.mul(L,H),p=t.mul(Z,V),v=t.add(p,v),p=t.sub(A,v),v=t.add(A,v),B=t.mul(p,v),A=t.add(I,I),A=t.add(A,I),V=t.mul(L,V),H=t.mul(Z,H),A=t.add(A,V),V=t.sub(I,V),V=t.mul(L,V),H=t.add(H,V),I=t.mul(A,H),B=t.add(B,I),I=t.mul(U,H),p=t.mul(T,p),p=t.sub(p,I),I=t.mul(T,A),v=t.mul(U,v),v=t.add(v,I),new S(p,B,v)}subtract(l){return this.add(l.negate())}is0(){return this.equals(S.ZERO)}multiply(l){const{endo:a}=e;if(!n.isValidNot0(l))throw new Error("invalid scalar: out of range");let u,w;const m=E=>M.cached(this,E,b=>mt(S,b));if(a){const{k1neg:E,k1:b,k2neg:p,k2:B}=z(l),{p:v,f:L}=m(b),{p:Z,f:I}=m(B);w=L.add(I),u=tt(a.beta,v,Z,E,p)}else{const{p:E,f:b}=m(l);u=E,w=b}return mt(S,[u,w])[0]}multiplyUnsafe(l){const{endo:a}=e,u=this;if(!n.isValid(l))throw new Error("invalid scalar: out of range");if(l===D||u.is0())return S.ZERO;if(l===ot)return u;if(M.hasCache(this))return this.multiply(l);if(a){const{k1neg:w,k1:m,k2neg:E,k2:b}=z(l),{p1:p,p2:B}=ke(S,u,m,b);return tt(a.beta,p,B,w,E)}else return M.unsafe(u,l)}multiplyAndAddUnsafe(l,a,u){const w=this.multiplyUnsafe(a).add(l.multiplyUnsafe(u));return w.is0()?void 0:w}toAffine(l){return _(this,l)}isTorsionFree(){const{isTorsionFree:l}=e;return s===ot?!0:l?l(S,this):M.unsafe(this,f).is0()}clearCofactor(){const{clearCofactor:l}=e;return s===ot?this:l?l(S,this):this.multiplyUnsafe(s)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}toBytes(l=!0){return wt(l,"isCompressed"),this.assertValidity(),h(S,this,l)}toHex(l=!0){return rt(this.toBytes(l))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(l=!0){return this.toBytes(l)}_setWindowSize(l){this.precompute(l)}static normalizeZ(l){return mt(S,l)}static msm(l,a){return Le(S,n,l,a)}static fromPrivateKey(l){return S.BASE.multiply(et(n,l))}}S.BASE=new S(c.Gx,c.Gy,t.ONE),S.ZERO=new S(t.ZERO,t.ONE,t.ZERO),S.Fp=t,S.Fn=n;const at=n.BITS,M=new Ve(S,e.endo?Math.ceil(at/2):at);return S.BASE.precompute(8),S}function de(r){return Uint8Array.of(r?2:3)}function he(r,e){return{secretKey:e.BYTES,publicKey:1+r.BYTES,publicKeyUncompressed:1+2*r.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function Ce(r,e={}){const{Fn:o}=r,t=e.randomBytes||Dt,n=Object.assign(he(r.Fp,o),{seed:fe(o.ORDER)});function c(i){try{return!!et(o,i)}catch{return!1}}function s(i,h){const{publicKey:O,publicKeyUncompressed:R}=n;try{const F=i.length;return h===!0&&F!==O||h===!1&&F!==R?!1:!!r.fromBytes(i)}catch{return!1}}function f(i=t(n.seed)){return Ze(W(i,n.seed,"seed"),o.ORDER)}function d(i,h=!0){return r.BASE.multiply(et(o,i)).toBytes(h)}function g(i){const h=f(i);return{secretKey:h,publicKey:d(h)}}function y(i){if(typeof i=="bigint")return!1;if(i instanceof r)return!0;const{secretKey:h,publicKey:O,publicKeyUncompressed:R}=n;if(o.allowedLengths||h===O)return;const F=K("key",i).length;return F===O||F===R}function x(i,h,O=!0){if(y(i)===!0)throw new Error("first arg must be private key");if(y(h)===!1)throw new Error("second arg must be public key");const R=et(o,i);return r.fromHex(h).multiply(R).toBytes(O)}return Object.freeze({getPublicKey:d,getSharedSecret:x,keygen:g,Point:r,utils:{isValidSecretKey:c,isValidPublicKey:s,randomSecretKey:f,isValidPrivateKey:c,randomPrivateKey:f,normPrivateKeyToScalar:i=>et(o,i),precompute(i=8,h=r.BASE){return h.precompute(i,!1)}},lengths:n})}function Te(r,e,o={}){Yt(e),Ft(o,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const t=o.randomBytes||Dt,n=o.hmac||((a,...u)=>Jt(e,a,G(...u))),{Fp:c,Fn:s}=r,{ORDER:f,BITS:d}=s,{keygen:g,getPublicKey:y,getSharedSecret:x,utils:i,lengths:h}=Ce(r,o),O={prehash:!1,lowS:typeof o.lowS=="boolean"?o.lowS:!1,format:void 0,extraEntropy:!1},R="compact";function F(a){const u=f>>ot;return a>u}function j(a,u){if(!s.isValidNot0(u))throw new Error(`invalid signature ${a}: out of range 1..Point.Fn.ORDER`);return u}function it(a,u){Ot(u);const w=h.signature,m=u==="compact"?w:u==="recovered"?w+1:void 0;return W(a,m,`${u} signature`)}class k{constructor(u,w,m){this.r=j("r",u),this.s=j("s",w),m!=null&&(this.recovery=m),Object.freeze(this)}static fromBytes(u,w=R){it(u,w);let m;if(w==="der"){const{r:B,s:v}=Y.toSig(W(u));return new k(B,v)}w==="recovered"&&(m=u[0],w="compact",u=u.subarray(1));const E=s.BYTES,b=u.subarray(0,E),p=u.subarray(E,E*2);return new k(s.fromBytes(b),s.fromBytes(p),m)}static fromHex(u,w){return this.fromBytes(ht(u),w)}addRecoveryBit(u){return new k(this.r,this.s,u)}recoverPublicKey(u){const w=c.ORDER,{r:m,s:E,recovery:b}=this;if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");if(f*le<w&&b>1)throw new Error("recovery id is ambiguous for h>1 curve");const p=b===2||b===3?m+f:m;if(!c.isValid(p))throw new Error("recovery id 2 or 3 invalid");const B=c.toBytes(p),v=r.fromBytes(G(de((b&1)===0),B)),L=s.inv(p),Z=z(K("msgHash",u)),I=s.create(-Z*L),A=s.create(E*L),V=r.BASE.multiplyUnsafe(I).add(v.multiplyUnsafe(A));if(V.is0())throw new Error("point at infinify");return V.assertValidity(),V}hasHighS(){return F(this.s)}toBytes(u=R){if(Ot(u),u==="der")return ht(Y.hexFromSig(this));const w=s.toBytes(this.r),m=s.toBytes(this.s);if(u==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return G(Uint8Array.of(this.recovery),w,m)}return G(w,m)}toHex(u){return rt(this.toBytes(u))}assertValidity(){}static fromCompact(u){return k.fromBytes(K("sig",u),"compact")}static fromDER(u){return k.fromBytes(K("sig",u),"der")}normalizeS(){return this.hasHighS()?new k(this.r,s.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return rt(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return rt(this.toBytes("compact"))}}const X=o.bits2int||function(a){if(a.length>8192)throw new Error("input is too large");const u=pt(a),w=a.length*8-d;return w>0?u>>BigInt(w):u},z=o.bits2int_modN||function(a){return s.create(X(a))},_=st(d);function ft(a){return Ee("num < 2^"+d,a,D,_),s.toBytes(a)}function tt(a,u){return W(a,void 0,"message"),u?W(e(a),void 0,"prehashed message"):a}function S(a,u,w){if(["recovered","canonical"].some(A=>A in w))throw new Error("sign() legacy options not supported");const{lowS:m,prehash:E,extraEntropy:b}=vt(w,O);a=tt(a,E);const p=z(a),B=et(s,u),v=[ft(B),ft(p)];if(b!=null&&b!==!1){const A=b===!0?t(h.secretKey):b;v.push(K("extraEntropy",A))}const L=G(...v),Z=p;function I(A){const V=X(A);if(!s.isValidNot0(V))return;const T=s.inv(V),H=r.BASE.multiply(V).toAffine(),U=s.create(H.x);if(U===D)return;const ut=s.create(T*s.create(Z+U*B));if(ut===D)return;let Ht=(H.x===U?0:2)|Number(H.y&ot),Vt=ut;return m&&F(ut)&&(Vt=s.neg(ut),Ht^=1),new k(U,Vt,Ht)}return{seed:L,k2sig:I}}function at(a,u,w={}){a=K("message",a);const{seed:m,k2sig:E}=S(a,u,w);return Be(e.outputLen,s.BYTES,n)(m,E)}function M(a){let u;const w=typeof a=="string"||St(a),m=!w&&a!==null&&typeof a=="object"&&typeof a.r=="bigint"&&typeof a.s=="bigint";if(!w&&!m)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(m)u=new k(a.r,a.s);else if(w){try{u=k.fromBytes(K("sig",a),"der")}catch(E){if(!(E instanceof Y.Err))throw E}if(!u)try{u=k.fromBytes(K("sig",a),"compact")}catch{return!1}}return u||!1}function N(a,u,w,m={}){const{lowS:E,prehash:b,format:p}=vt(m,O);if(w=K("publicKey",w),u=tt(K("message",u),b),"strict"in m)throw new Error("options.strict was renamed to lowS");const B=p===void 0?M(a):k.fromBytes(K("sig",a),p);if(B===!1)return!1;try{const v=r.fromBytes(w);if(E&&B.hasHighS())return!1;const{r:L,s:Z}=B,I=z(u),A=s.inv(Z),V=s.create(I*A),T=s.create(L*A),H=r.BASE.multiplyUnsafe(V).add(v.multiplyUnsafe(T));return H.is0()?!1:s.create(H.x)===L}catch{return!1}}function l(a,u,w={}){const{prehash:m}=vt(w,O);return u=tt(u,m),k.fromBytes(a,"recovered").recoverPublicKey(u).toBytes()}return Object.freeze({keygen:g,getPublicKey:y,getSharedSecret:x,utils:i,lengths:h,Point:r,sign:at,verify:N,recoverPublicKey:l,Signature:k,hash:e})}function je(r){const e={a:r.a,b:r.b,p:r.Fp.ORDER,n:r.n,h:r.h,Gx:r.Gx,Gy:r.Gy},o=r.Fp;let t=r.allowedPrivateKeyLengths?Array.from(new Set(r.allowedPrivateKeyLengths.map(s=>Math.ceil(s/2)))):void 0;const n=ct(e.n,{BITS:r.nBitLength,allowedLengths:t,modFromBytes:r.wrapPrivateKey}),c={Fp:o,Fn:n,allowInfinityPoint:r.allowInfinityPoint,endo:r.endo,isTorsionFree:r.isTorsionFree,clearCofactor:r.clearCofactor,fromBytes:r.fromBytes,toBytes:r.toBytes};return{CURVE:e,curveOpts:c}}function Ye(r){const{CURVE:e,curveOpts:o}=je(r),t={hmac:r.hmac,randomBytes:r.randomBytes,lowS:r.lowS,bits2int:r.bits2int,bits2int_modN:r.bits2int_modN};return{CURVE:e,curveOpts:o,hash:r.hash,ecdsaOpts:t}}function De(r,e){const o=e.Point;return Object.assign({},e,{ProjectivePoint:o,CURVE:Object.assign({},r,se(o.Fn.ORDER,o.Fn.BITS))})}function ze(r){const{CURVE:e,curveOpts:o,hash:t,ecdsaOpts:n}=Ye(r),c=$e(e,o),s=Te(c,t,n);return De(r,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ge(r,e){const o=t=>ze({...r,hash:t});return{...o(e),create:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const At={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Xe={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Tt=BigInt(2);function Me(r){const e=At.p,o=BigInt(3),t=BigInt(6),n=BigInt(11),c=BigInt(22),s=BigInt(23),f=BigInt(44),d=BigInt(88),g=r*r*r%e,y=g*g*r%e,x=$(y,o,e)*y%e,i=$(x,o,e)*y%e,h=$(i,Tt,e)*g%e,O=$(h,n,e)*h%e,R=$(O,c,e)*O%e,F=$(R,f,e)*R%e,j=$(F,d,e)*F%e,it=$(j,f,e)*R%e,k=$(it,o,e)*y%e,X=$(k,s,e)*O%e,z=$(X,t,e)*g%e,_=$(z,Tt,e);if(!Rt.eql(Rt.sqr(_),r))throw new Error("Cannot find square root");return _}const Rt=ct(At.p,{sqrt:Me}),Je=Ge({...At,Fp:Rt,lowS:!0,endo:Xe},ge);export{Je as secp256k1};
