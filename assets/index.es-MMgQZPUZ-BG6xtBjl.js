import{as as z}from"./index-BOQakz6i.js";new Uint8Array(new Uint32Array([287454020]).buffer)[0];function Ft(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function gr(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function _t(t,...e){if(!gr(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function wr(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Ft(t.outputLen),Ft(t.blockLen)}function mt(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Fe(t,e){_t(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}const Rt=BigInt(2**32-1),de=BigInt(32);function yr(t,e=!1){return e?{h:Number(t&Rt),l:Number(t>>de&Rt)}:{h:Number(t>>de&Rt)|0,l:Number(t&Rt)|0}}function br(t,e=!1){let r=new Uint32Array(t.length),n=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:o,l:i}=yr(t[s],e);[r[s],n[s]]=[o,i]}return[r,n]}const mr=(t,e,r)=>t<<r|e>>>32-r,Er=(t,e,r)=>e<<r|t>>>32-r,xr=(t,e,r)=>e<<r-32|t>>>64-r,Br=(t,e,r)=>t<<r-32|e>>>64-r,wt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function Ar(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function Zt(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function nt(t,e){return t<<32-e|t>>>e}const pe=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function vr(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}function ge(t){for(let e=0;e<t.length;e++)t[e]=vr(t[e])}function Ir(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function Ct(t){return typeof t=="string"&&(t=Ir(t)),_t(t),t}function Ur(...t){let e=0;for(let n=0;n<t.length;n++){const s=t[n];_t(s),e+=s.length}const r=new Uint8Array(e);for(let n=0,s=0;n<t.length;n++){const o=t[n];r.set(o,s),s+=o.length}return r}let fe=class{clone(){return this._cloneInto()}};function Ce(t){const e=n=>t().update(Ct(n)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function ze(t=32){if(wt&&typeof wt.getRandomValues=="function")return wt.getRandomValues(new Uint8Array(t));if(wt&&typeof wt.randomBytes=="function")return wt.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}const je=[],He=[],Me=[],Sr=BigInt(0),Ot=BigInt(1),Or=BigInt(2),Nr=BigInt(7),Lr=BigInt(256),_r=BigInt(113);for(let t=0,e=Ot,r=1,n=0;t<24;t++){[r,n]=[n,(2*r+3*n)%5],je.push(2*(5*n+r)),He.push((t+1)*(t+2)/2%64);let s=Sr;for(let o=0;o<7;o++)e=(e<<Ot^(e>>Nr)*_r)%Lr,e&Or&&(s^=Ot<<(Ot<<BigInt(o))-Ot);Me.push(s)}const[Tr,kr]=br(Me,!0),we=(t,e,r)=>r>32?xr(t,e,r):mr(t,e,r),ye=(t,e,r)=>r>32?Br(t,e,r):Er(t,e,r);function Rr(t,e=24){const r=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)r[i]=t[i]^t[i+10]^t[i+20]^t[i+30]^t[i+40];for(let i=0;i<10;i+=2){const c=(i+8)%10,a=(i+2)%10,u=r[a],h=r[a+1],B=we(u,h,1)^r[c],p=ye(u,h,1)^r[c+1];for(let U=0;U<50;U+=10)t[i+U]^=B,t[i+U+1]^=p}let s=t[2],o=t[3];for(let i=0;i<24;i++){const c=He[i],a=we(s,o,c),u=ye(s,o,c),h=je[i];s=t[h],o=t[h+1],t[h]=a,t[h+1]=u}for(let i=0;i<50;i+=10){for(let c=0;c<10;c++)r[c]=t[i+c];for(let c=0;c<10;c++)t[i+c]^=~r[(c+2)%10]&r[(c+4)%10]}t[0]^=Tr[n],t[1]^=kr[n]}r.fill(0)}let Pr=class De extends fe{constructor(e,r,n,s=!1,o=24){if(super(),this.blockLen=e,this.suffix=r,this.outputLen=n,this.enableXOF=s,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Ft(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Ar(this.state)}keccak(){pe||ge(this.state32),Rr(this.state32,this.rounds),pe||ge(this.state32),this.posOut=0,this.pos=0}update(e){mt(this);const{blockLen:r,state:n}=this;e=Ct(e);const s=e.length;for(let o=0;o<s;){const i=Math.min(r-this.pos,s-o);for(let c=0;c<i;c++)n[this.pos++]^=e[o++];this.pos===r&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:r,pos:n,blockLen:s}=this;e[n]^=r,r&128&&n===s-1&&this.keccak(),e[s-1]^=128,this.keccak()}writeInto(e){mt(this,!1),_t(e),this.finish();const r=this.state,{blockLen:n}=this;for(let s=0,o=e.length;s<o;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,o-s);e.set(r.subarray(this.posOut,this.posOut+i),s),this.posOut+=i,s+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Ft(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(Fe(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:r,suffix:n,outputLen:s,rounds:o,enableXOF:i}=this;return e||(e=new De(r,n,s,i,o)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=o,e.suffix=n,e.outputLen=s,e.enableXOF=i,e.destroyed=this.destroyed,e}};const qr=(t,e,r)=>Ce(()=>new Pr(e,t,r));qr(1,136,256/8);function Yt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function Ve(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function tt(t,...e){if(!Ve(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function be(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Fr(t,e){tt(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}function me(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}const ut=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),Cr=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),zr=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!zr)throw new Error("Non little-endian hardware is not supported");function jr(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function te(t){if(typeof t=="string")t=jr(t);else if(Ve(t))t=ee(t);else throw new Error("Uint8Array expected, got "+typeof t);return t}function Hr(t,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(t,e)}function Mr(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return r===0}const Dr=(t,e)=>{function r(n,...s){if(tt(n),t.nonceLength!==void 0){const u=s[0];if(!u)throw new Error("nonce / iv required");t.varSizeNonce?tt(u):tt(u,t.nonceLength)}const o=t.tagLength;o&&s[1]!==void 0&&tt(s[1]);const i=e(n,...s),c=(u,h)=>{if(h!==void 0){if(u!==2)throw new Error("cipher output not supported");tt(h)}};let a=!1;return{encrypt(u,h){if(a)throw new Error("cannot encrypt() twice with same key + nonce");return a=!0,tt(u),c(i.encrypt.length,h),i.encrypt(u,h)},decrypt(u,h){if(tt(u),o&&u.length<o)throw new Error("invalid ciphertext length: smaller than tagLength="+o);return c(i.decrypt.length,h),i.decrypt(u,h)}}}return Object.assign(r,t),r};function Ee(t,e,r=!0){if(e===void 0)return new Uint8Array(t);if(e.length!==t)throw new Error("invalid output length, expected "+t+", got: "+e.length);if(r&&!Vr(e))throw new Error("invalid output, must be aligned");return e}function xe(t,e,r,n){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,r,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(r>>s&o),c=Number(r&o);t.setUint32(e+4,i,n),t.setUint32(e+0,c,n)}function Vr(t){return t.byteOffset%4===0}function ee(t){return Uint8Array.from(t)}function Et(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}const Ze=t=>Uint8Array.from(t.split("").map(e=>e.charCodeAt(0))),Zr=Ze("expand 16-byte k"),Yr=Ze("expand 32-byte k"),Kr=ut(Zr),Gr=ut(Yr);function j(t,e){return t<<e|t>>>32-e}function re(t){return t.byteOffset%4===0}const Pt=64,Wr=16,Ye=2**32-1,Be=new Uint32Array;function Xr(t,e,r,n,s,o,i,c){const a=s.length,u=new Uint8Array(Pt),h=ut(u),B=re(s)&&re(o),p=B?ut(s):Be,U=B?ut(o):Be;for(let w=0;w<a;i++){if(t(e,r,n,h,i,c),i>=Ye)throw new Error("arx: counter overflow");const y=Math.min(Pt,a-w);if(B&&y===Pt){const f=w/4;if(w%4!==0)throw new Error("arx: invalid block position");for(let g=0,l;g<Wr;g++)l=f+g,U[l]=p[l]^h[g];w+=Pt;continue}for(let f=0,g;f<y;f++)g=w+f,o[g]=s[g]^u[f];w+=y}}function $r(t,e){const{allowShortKeys:r,extendNonceFn:n,counterLength:s,counterRight:o,rounds:i}=Hr({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof t!="function")throw new Error("core must be a function");return Yt(s),Yt(i),me(o),me(r),(c,a,u,h,B=0)=>{tt(c),tt(a),tt(u);const p=u.length;if(h===void 0&&(h=new Uint8Array(p)),tt(h),Yt(B),B<0||B>=Ye)throw new Error("arx: counter overflow");if(h.length<p)throw new Error(`arx: output (${h.length}) is shorter than data (${p})`);const U=[];let w=c.length,y,f;if(w===32)U.push(y=ee(c)),f=Gr;else if(w===16&&r)y=new Uint8Array(32),y.set(c),y.set(c,16),f=Kr,U.push(y);else throw new Error(`arx: invalid 32-byte key, got length=${w}`);re(a)||U.push(a=ee(a));const g=ut(y);if(n){if(a.length!==24)throw new Error("arx: extended nonce must be 24 bytes");n(f,g,ut(a.subarray(0,16)),g),a=a.subarray(16)}const l=16-s;if(l!==a.length)throw new Error(`arx: nonce must be ${l} or 16 bytes`);if(l!==12){const O=new Uint8Array(12);O.set(a,o?0:12-a.length),a=O,U.push(a)}const A=ut(a);return Xr(t,f,g,A,u,h,B,i),Et(...U),h}}const Y=(t,e)=>t[e++]&255|(t[e++]&255)<<8;class Jr{constructor(e){this.blockLen=16,this.outputLen=16,this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.pos=0,this.finished=!1,e=te(e),tt(e,32);const r=Y(e,0),n=Y(e,2),s=Y(e,4),o=Y(e,6),i=Y(e,8),c=Y(e,10),a=Y(e,12),u=Y(e,14);this.r[0]=r&8191,this.r[1]=(r>>>13|n<<3)&8191,this.r[2]=(n>>>10|s<<6)&7939,this.r[3]=(s>>>7|o<<9)&8191,this.r[4]=(o>>>4|i<<12)&255,this.r[5]=i>>>1&8190,this.r[6]=(i>>>14|c<<2)&8191,this.r[7]=(c>>>11|a<<5)&8065,this.r[8]=(a>>>8|u<<8)&8191,this.r[9]=u>>>5&127;for(let h=0;h<8;h++)this.pad[h]=Y(e,16+2*h)}process(e,r,n=!1){const s=n?0:2048,{h:o,r:i}=this,c=i[0],a=i[1],u=i[2],h=i[3],B=i[4],p=i[5],U=i[6],w=i[7],y=i[8],f=i[9],g=Y(e,r+0),l=Y(e,r+2),A=Y(e,r+4),O=Y(e,r+6),k=Y(e,r+8),S=Y(e,r+10),E=Y(e,r+12),I=Y(e,r+14);let x=o[0]+(g&8191),R=o[1]+((g>>>13|l<<3)&8191),L=o[2]+((l>>>10|A<<6)&8191),T=o[3]+((A>>>7|O<<9)&8191),P=o[4]+((O>>>4|k<<12)&8191),d=o[5]+(k>>>1&8191),b=o[6]+((k>>>14|S<<2)&8191),m=o[7]+((S>>>11|E<<5)&8191),N=o[8]+((E>>>8|I<<8)&8191),_=o[9]+(I>>>5|s),v=0,F=v+x*c+R*(5*f)+L*(5*y)+T*(5*w)+P*(5*U);v=F>>>13,F&=8191,F+=d*(5*p)+b*(5*B)+m*(5*h)+N*(5*u)+_*(5*a),v+=F>>>13,F&=8191;let q=v+x*a+R*c+L*(5*f)+T*(5*y)+P*(5*w);v=q>>>13,q&=8191,q+=d*(5*U)+b*(5*p)+m*(5*B)+N*(5*h)+_*(5*u),v+=q>>>13,q&=8191;let C=v+x*u+R*a+L*c+T*(5*f)+P*(5*y);v=C>>>13,C&=8191,C+=d*(5*w)+b*(5*U)+m*(5*p)+N*(5*B)+_*(5*h),v+=C>>>13,C&=8191;let H=v+x*h+R*u+L*a+T*c+P*(5*f);v=H>>>13,H&=8191,H+=d*(5*y)+b*(5*w)+m*(5*U)+N*(5*p)+_*(5*B),v+=H>>>13,H&=8191;let M=v+x*B+R*h+L*u+T*a+P*c;v=M>>>13,M&=8191,M+=d*(5*f)+b*(5*y)+m*(5*w)+N*(5*U)+_*(5*p),v+=M>>>13,M&=8191;let G=v+x*p+R*B+L*h+T*u+P*a;v=G>>>13,G&=8191,G+=d*c+b*(5*f)+m*(5*y)+N*(5*w)+_*(5*U),v+=G>>>13,G&=8191;let W=v+x*U+R*p+L*B+T*h+P*u;v=W>>>13,W&=8191,W+=d*a+b*c+m*(5*f)+N*(5*y)+_*(5*w),v+=W>>>13,W&=8191;let rt=v+x*w+R*U+L*p+T*B+P*h;v=rt>>>13,rt&=8191,rt+=d*u+b*a+m*c+N*(5*f)+_*(5*y),v+=rt>>>13,rt&=8191;let X=v+x*y+R*w+L*U+T*p+P*B;v=X>>>13,X&=8191,X+=d*h+b*u+m*a+N*c+_*(5*f),v+=X>>>13,X&=8191;let J=v+x*f+R*y+L*w+T*U+P*p;v=J>>>13,J&=8191,J+=d*B+b*h+m*u+N*a+_*c,v+=J>>>13,J&=8191,v=(v<<2)+v|0,v=v+F|0,F=v&8191,v=v>>>13,q+=v,o[0]=F,o[1]=q,o[2]=C,o[3]=H,o[4]=M,o[5]=G,o[6]=W,o[7]=rt,o[8]=X,o[9]=J}finalize(){const{h:e,pad:r}=this,n=new Uint16Array(10);let s=e[1]>>>13;e[1]&=8191;for(let c=2;c<10;c++)e[c]+=s,s=e[c]>>>13,e[c]&=8191;e[0]+=s*5,s=e[0]>>>13,e[0]&=8191,e[1]+=s,s=e[1]>>>13,e[1]&=8191,e[2]+=s,n[0]=e[0]+5,s=n[0]>>>13,n[0]&=8191;for(let c=1;c<10;c++)n[c]=e[c]+s,s=n[c]>>>13,n[c]&=8191;n[9]-=8192;let o=(s^1)-1;for(let c=0;c<10;c++)n[c]&=o;o=~o;for(let c=0;c<10;c++)e[c]=e[c]&o|n[c];e[0]=(e[0]|e[1]<<13)&65535,e[1]=(e[1]>>>3|e[2]<<10)&65535,e[2]=(e[2]>>>6|e[3]<<7)&65535,e[3]=(e[3]>>>9|e[4]<<4)&65535,e[4]=(e[4]>>>12|e[5]<<1|e[6]<<14)&65535,e[5]=(e[6]>>>2|e[7]<<11)&65535,e[6]=(e[7]>>>5|e[8]<<8)&65535,e[7]=(e[8]>>>8|e[9]<<5)&65535;let i=e[0]+r[0];e[0]=i&65535;for(let c=1;c<8;c++)i=(e[c]+r[c]|0)+(i>>>16)|0,e[c]=i&65535;Et(n)}update(e){be(this);const{buffer:r,blockLen:n}=this;e=te(e);const s=e.length;for(let o=0;o<s;){const i=Math.min(n-this.pos,s-o);if(i===n){for(;n<=s-o;o+=n)this.process(e,o);continue}r.set(e.subarray(o,o+i),this.pos),this.pos+=i,o+=i,this.pos===n&&(this.process(r,0,!1),this.pos=0)}return this}destroy(){Et(this.h,this.r,this.buffer,this.pad)}digestInto(e){be(this),Fr(e,this),this.finished=!0;const{buffer:r,h:n}=this;let{pos:s}=this;if(s){for(r[s++]=1;s<16;s++)r[s]=0;this.process(r,0,!0)}this.finalize();let o=0;for(let i=0;i<8;i++)e[o++]=n[i]>>>0,e[o++]=n[i]>>>8;return e}digest(){const{buffer:e,outputLen:r}=this;this.digestInto(e);const n=e.slice(0,r);return this.destroy(),n}}function Qr(t){const e=(n,s)=>t(s).update(te(n)).digest(),r=t(new Uint8Array(32));return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=n=>t(n),e}const tn=Qr(t=>new Jr(t));function en(t,e,r,n,s,o=20){let i=t[0],c=t[1],a=t[2],u=t[3],h=e[0],B=e[1],p=e[2],U=e[3],w=e[4],y=e[5],f=e[6],g=e[7],l=s,A=r[0],O=r[1],k=r[2],S=i,E=c,I=a,x=u,R=h,L=B,T=p,P=U,d=w,b=y,m=f,N=g,_=l,v=A,F=O,q=k;for(let H=0;H<o;H+=2)S=S+R|0,_=j(_^S,16),d=d+_|0,R=j(R^d,12),S=S+R|0,_=j(_^S,8),d=d+_|0,R=j(R^d,7),E=E+L|0,v=j(v^E,16),b=b+v|0,L=j(L^b,12),E=E+L|0,v=j(v^E,8),b=b+v|0,L=j(L^b,7),I=I+T|0,F=j(F^I,16),m=m+F|0,T=j(T^m,12),I=I+T|0,F=j(F^I,8),m=m+F|0,T=j(T^m,7),x=x+P|0,q=j(q^x,16),N=N+q|0,P=j(P^N,12),x=x+P|0,q=j(q^x,8),N=N+q|0,P=j(P^N,7),S=S+L|0,q=j(q^S,16),m=m+q|0,L=j(L^m,12),S=S+L|0,q=j(q^S,8),m=m+q|0,L=j(L^m,7),E=E+T|0,_=j(_^E,16),N=N+_|0,T=j(T^N,12),E=E+T|0,_=j(_^E,8),N=N+_|0,T=j(T^N,7),I=I+P|0,v=j(v^I,16),d=d+v|0,P=j(P^d,12),I=I+P|0,v=j(v^I,8),d=d+v|0,P=j(P^d,7),x=x+R|0,F=j(F^x,16),b=b+F|0,R=j(R^b,12),x=x+R|0,F=j(F^x,8),b=b+F|0,R=j(R^b,7);let C=0;n[C++]=i+S|0,n[C++]=c+E|0,n[C++]=a+I|0,n[C++]=u+x|0,n[C++]=h+R|0,n[C++]=B+L|0,n[C++]=p+T|0,n[C++]=U+P|0,n[C++]=w+d|0,n[C++]=y+b|0,n[C++]=f+m|0,n[C++]=g+N|0,n[C++]=l+_|0,n[C++]=A+v|0,n[C++]=O+F|0,n[C++]=k+q|0}const rn=$r(en,{counterRight:!1,counterLength:4,allowShortKeys:!1}),nn=new Uint8Array(16),Ae=(t,e)=>{t.update(e);const r=e.length%16;r&&t.update(nn.subarray(r))},on=new Uint8Array(32);function ve(t,e,r,n,s){const o=t(e,r,on),i=tn.create(o);s&&Ae(i,s),Ae(i,n);const c=new Uint8Array(16),a=Cr(c);xe(a,0,BigInt(s?s.length:0),!0),xe(a,8,BigInt(n.length),!0),i.update(c);const u=i.digest();return Et(o,c),u}const sn=t=>(e,r,n)=>({encrypt(s,o){const i=s.length;o=Ee(i+16,o,!1),o.set(s);const c=o.subarray(0,-16);t(e,r,c,c,1);const a=ve(t,e,r,c,n);return o.set(a,i),Et(a),o},decrypt(s,o){o=Ee(s.length-16,o,!1);const i=s.subarray(0,-16),c=s.subarray(-16),a=ve(t,e,r,i,n);if(!Mr(c,a))throw new Error("invalid tag");return o.set(s.subarray(0,-16)),t(e,r,o,o,1),Et(a),o}});Dr({blockSize:64,nonceLength:12,tagLength:16},sn(rn));let Ke=class extends fe{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,wr(t);const r=Ct(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,s=new Uint8Array(n);s.set(r.length>n?t.create().update(r).digest():r);for(let o=0;o<s.length;o++)s[o]^=54;this.iHash.update(s),this.oHash=t.create();for(let o=0;o<s.length;o++)s[o]^=106;this.oHash.update(s),s.fill(0)}update(t){return mt(this),this.iHash.update(t),this}digestInto(t){mt(this),_t(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:s,blockLen:o,outputLen:i}=this;return t=t,t.finished=n,t.destroyed=s,t.blockLen=o,t.outputLen=i,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const Ge=(t,e,r)=>new Ke(t,e).update(r).digest();Ge.create=(t,e)=>new Ke(t,e);function an(t,e,r,n){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,r,n);const s=BigInt(32),o=BigInt(4294967295),i=Number(r>>s&o),c=Number(r&o),a=n?4:0,u=n?0:4;t.setUint32(e+a,i,n),t.setUint32(e+u,c,n)}function cn(t,e,r){return t&e^~t&r}function fn(t,e,r){return t&e^t&r^e&r}let un=class extends fe{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=Zt(this.buffer)}update(t){mt(this);const{view:e,buffer:r,blockLen:n}=this;t=Ct(t);const s=t.length;for(let o=0;o<s;){const i=Math.min(n-this.pos,s-o);if(i===n){const c=Zt(t);for(;n<=s-o;o+=n)this.process(c,o);continue}r.set(t.subarray(o,o+i),this.pos),this.pos+=i,o+=i,this.pos===n&&(this.process(e,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){mt(this),Fe(t,this),this.finished=!0;const{buffer:e,view:r,blockLen:n,isLE:s}=this;let{pos:o}=this;e[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>n-o&&(this.process(r,0),o=0);for(let h=o;h<n;h++)e[h]=0;an(r,n-8,BigInt(this.length*8),s),this.process(r,0);const i=Zt(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=c/4,u=this.get();if(a>u.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<a;h++)i.setUint32(4*h,u[h],s)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:s,destroyed:o,pos:i}=this;return t.length=n,t.pos=i,t.finished=s,t.destroyed=o,n%e&&t.buffer.set(r),t}};const hn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ct=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),ft=new Uint32Array(64);class ln extends un{constructor(){super(64,32,8,!1),this.A=ct[0]|0,this.B=ct[1]|0,this.C=ct[2]|0,this.D=ct[3]|0,this.E=ct[4]|0,this.F=ct[5]|0,this.G=ct[6]|0,this.H=ct[7]|0}get(){const{A:e,B:r,C:n,D:s,E:o,F:i,G:c,H:a}=this;return[e,r,n,s,o,i,c,a]}set(e,r,n,s,o,i,c,a){this.A=e|0,this.B=r|0,this.C=n|0,this.D=s|0,this.E=o|0,this.F=i|0,this.G=c|0,this.H=a|0}process(e,r){for(let B=0;B<16;B++,r+=4)ft[B]=e.getUint32(r,!1);for(let B=16;B<64;B++){const p=ft[B-15],U=ft[B-2],w=nt(p,7)^nt(p,18)^p>>>3,y=nt(U,17)^nt(U,19)^U>>>10;ft[B]=y+ft[B-7]+w+ft[B-16]|0}let{A:n,B:s,C:o,D:i,E:c,F:a,G:u,H:h}=this;for(let B=0;B<64;B++){const p=nt(c,6)^nt(c,11)^nt(c,25),U=h+p+cn(c,a,u)+hn[B]+ft[B]|0,w=(nt(n,2)^nt(n,13)^nt(n,22))+fn(n,s,o)|0;h=u,u=a,a=c,c=i+U|0,i=o,o=s,s=n,n=U+w|0}n=n+this.A|0,s=s+this.B|0,o=o+this.C|0,i=i+this.D|0,c=c+this.E|0,a=a+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(n,s,o,i,c,a,u,h)}roundClean(){ft.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const dn=Ce(()=>new ln);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zt=BigInt(0),jt=BigInt(1),pn=BigInt(2);function gt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Tt(t){if(!gt(t))throw new Error("Uint8Array expected")}function xt(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}const gn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Bt(t){Tt(t);let e="";for(let r=0;r<t.length;r++)e+=gn[t[r]];return e}function bt(t){const e=t.toString(16);return e.length&1?"0"+e:e}function ue(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?zt:BigInt("0x"+t)}const ot={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ie(t){if(t>=ot._0&&t<=ot._9)return t-ot._0;if(t>=ot.A&&t<=ot.F)return t-(ot.A-10);if(t>=ot.a&&t<=ot.f)return t-(ot.a-10)}function At(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let s=0,o=0;s<r;s++,o+=2){const i=Ie(t.charCodeAt(o)),c=Ie(t.charCodeAt(o+1));if(i===void 0||c===void 0){const a=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+o)}n[s]=i*16+c}return n}function pt(t){return ue(Bt(t))}function Nt(t){return Tt(t),ue(Bt(Uint8Array.from(t).reverse()))}function vt(t,e){return At(t.toString(16).padStart(e*2,"0"))}function Ht(t,e){return vt(t,e).reverse()}function wn(t){return At(bt(t))}function Q(t,e,r){let n;if(typeof e=="string")try{n=At(e)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(gt(e))n=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const s=n.length;if(typeof r=="number"&&s!==r)throw new Error(t+" of length "+r+" expected, got "+s);return n}function Lt(...t){let e=0;for(let n=0;n<t.length;n++){const s=t[n];Tt(s),e+=s.length}const r=new Uint8Array(e);for(let n=0,s=0;n<t.length;n++){const o=t[n];r.set(o,s),s+=o.length}return r}function yn(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return r===0}function bn(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const Kt=t=>typeof t=="bigint"&&zt<=t;function Mt(t,e,r){return Kt(t)&&Kt(e)&&Kt(r)&&e<=t&&t<r}function at(t,e,r,n){if(!Mt(e,r,n))throw new Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function We(t){let e;for(e=0;t>zt;t>>=jt,e+=1);return e}function mn(t,e){return t>>BigInt(e)&jt}function En(t,e,r){return t|(r?jt:zt)<<BigInt(e)}const he=t=>(pn<<BigInt(t-1))-jt,Gt=t=>new Uint8Array(t),Ue=t=>Uint8Array.from(t);function Xe(t,e,r){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");let n=Gt(t),s=Gt(t),o=0;const i=()=>{n.fill(1),s.fill(0),o=0},c=(...h)=>r(s,n,...h),a=(h=Gt())=>{s=c(Ue([0]),h),n=c(),h.length!==0&&(s=c(Ue([1]),h),n=c())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const B=[];for(;h<e;){n=c();const p=n.slice();B.push(p),h+=n.length}return Lt(...B)};return(h,B)=>{i(),a(h);let p;for(;!(p=B(u()));)a();return i(),p}}const xn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||gt(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function It(t,e,r={}){const n=(s,o,i)=>{const c=xn[o];if(typeof c!="function")throw new Error("invalid validator function");const a=t[s];if(!(i&&a===void 0)&&!c(a,t))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+a)};for(const[s,o]of Object.entries(e))n(s,o,!1);for(const[s,o]of Object.entries(r))n(s,o,!0);return t}const Bn=()=>{throw new Error("not implemented")};function ne(t){const e=new WeakMap;return(r,...n)=>{const s=e.get(r);if(s!==void 0)return s;const o=t(r,...n);return e.set(r,o),o}}var An=Object.freeze({__proto__:null,isBytes:gt,abytes:Tt,abool:xt,bytesToHex:Bt,numberToHexUnpadded:bt,hexToNumber:ue,hexToBytes:At,bytesToNumberBE:pt,bytesToNumberLE:Nt,numberToBytesBE:vt,numberToBytesLE:Ht,numberToVarBytesBE:wn,ensureBytes:Q,concatBytes:Lt,equalBytes:yn,utf8ToBytes:bn,inRange:Mt,aInRange:at,bitLen:We,bitGet:mn,bitSet:En,bitMask:he,createHmacDrbg:Xe,validateObject:It,notImplemented:Bn,memoized:ne});const Z=BigInt(0),D=BigInt(1),dt=BigInt(2),vn=BigInt(3),oe=BigInt(4),Se=BigInt(5),Oe=BigInt(8);function $(t,e){const r=t%e;return r>=Z?r:e+r}function $e(t,e,r){if(e<Z)throw new Error("invalid exponent, negatives unsupported");if(r<=Z)throw new Error("invalid modulus");if(r===D)return Z;let n=D;for(;e>Z;)e&D&&(n=n*t%r),t=t*t%r,e>>=D;return n}function et(t,e,r){let n=t;for(;e-- >Z;)n*=n,n%=r;return n}function se(t,e){if(t===Z)throw new Error("invert: expected non-zero number");if(e<=Z)throw new Error("invert: expected positive modulus, got "+e);let r=$(t,e),n=e,s=Z,o=D;for(;r!==Z;){const i=n/r,c=n%r,a=s-o*i;n=r,r=c,s=o,o=a}if(n!==D)throw new Error("invert: does not exist");return $(s,e)}function In(t){const e=(t-D)/dt;let r,n,s;for(r=t-D,n=0;r%dt===Z;r/=dt,n++);for(s=dt;s<t&&$e(s,e,t)!==t-D;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(n===1){const i=(t+D)/oe;return function(c,a){const u=c.pow(a,i);if(!c.eql(c.sqr(u),a))throw new Error("Cannot find square root");return u}}const o=(r+D)/dt;return function(i,c){if(i.pow(c,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=n,u=i.pow(i.mul(i.ONE,s),r),h=i.pow(c,o),B=i.pow(c,r);for(;!i.eql(B,i.ONE);){if(i.eql(B,i.ZERO))return i.ZERO;let p=1;for(let w=i.sqr(B);p<a&&!i.eql(w,i.ONE);p++)w=i.sqr(w);const U=i.pow(u,D<<BigInt(a-p-1));u=i.sqr(U),h=i.mul(h,U),B=i.mul(B,u),a=p}return h}}function Un(t){if(t%oe===vn){const e=(t+D)/oe;return function(r,n){const s=r.pow(n,e);if(!r.eql(r.sqr(s),n))throw new Error("Cannot find square root");return s}}if(t%Oe===Se){const e=(t-Se)/Oe;return function(r,n){const s=r.mul(n,dt),o=r.pow(s,e),i=r.mul(n,o),c=r.mul(r.mul(i,dt),o),a=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(a),n))throw new Error("Cannot find square root");return a}}return In(t)}const Sn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function On(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},r=Sn.reduce((n,s)=>(n[s]="function",n),e);return It(t,r)}function Nn(t,e,r){if(r<Z)throw new Error("invalid exponent, negatives unsupported");if(r===Z)return t.ONE;if(r===D)return e;let n=t.ONE,s=e;for(;r>Z;)r&D&&(n=t.mul(n,s)),s=t.sqr(s),r>>=D;return n}function Ln(t,e){const r=new Array(e.length),n=e.reduce((o,i,c)=>t.is0(i)?o:(r[c]=o,t.mul(o,i)),t.ONE),s=t.inv(n);return e.reduceRight((o,i,c)=>t.is0(i)?o:(r[c]=t.mul(o,r[c]),t.mul(o,i)),s),r}function Je(t,e){const r=e!==void 0?e:t.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function Qe(t,e,r=!1,n={}){if(t<=Z)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:s,nByteLength:o}=Je(t,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let i;const c=Object.freeze({ORDER:t,isLE:r,BITS:s,BYTES:o,MASK:he(s),ZERO:Z,ONE:D,create:a=>$(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return Z<=a&&a<t},is0:a=>a===Z,isOdd:a=>(a&D)===D,neg:a=>$(-a,t),eql:(a,u)=>a===u,sqr:a=>$(a*a,t),add:(a,u)=>$(a+u,t),sub:(a,u)=>$(a-u,t),mul:(a,u)=>$(a*u,t),pow:(a,u)=>Nn(c,a,u),div:(a,u)=>$(a*se(u,t),t),sqrN:a=>a*a,addN:(a,u)=>a+u,subN:(a,u)=>a-u,mulN:(a,u)=>a*u,inv:a=>se(a,t),sqrt:n.sqrt||(a=>(i||(i=Un(t)),i(c,a))),invertBatch:a=>Ln(c,a),cmov:(a,u,h)=>h?u:a,toBytes:a=>r?Ht(a,o):vt(a,o),fromBytes:a=>{if(a.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+a.length);return r?Nt(a):pt(a)}});return Object.freeze(c)}function tr(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function er(t){const e=tr(t);return e+Math.ceil(e/2)}function _n(t,e,r=!1){const n=t.length,s=tr(e),o=er(e);if(n<16||n<o||n>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+n);const i=r?Nt(t):pt(t),c=$(i,e-D)+D;return r?Ht(c,s):vt(c,s)}const Ne=BigInt(0),qt=BigInt(1);function Wt(t,e){const r=e.negate();return t?r:e}function rr(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Xt(t,e){rr(t,e);const r=Math.ceil(e/t)+1,n=2**(t-1);return{windows:r,windowSize:n}}function Tn(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((r,n)=>{if(!(r instanceof e))throw new Error("invalid point at index "+n)})}function kn(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((r,n)=>{if(!e.isValid(r))throw new Error("invalid scalar at index "+n)})}const $t=new WeakMap,nr=new WeakMap;function Jt(t){return nr.get(t)||1}function Rn(t,e){return{constTimeNegate:Wt,hasPrecomputes(r){return Jt(r)!==1},unsafeLadder(r,n,s=t.ZERO){let o=r;for(;n>Ne;)n&qt&&(s=s.add(o)),o=o.double(),n>>=qt;return s},precomputeWindow(r,n){const{windows:s,windowSize:o}=Xt(n,e),i=[];let c=r,a=c;for(let u=0;u<s;u++){a=c,i.push(a);for(let h=1;h<o;h++)a=a.add(c),i.push(a);c=a.double()}return i},wNAF(r,n,s){const{windows:o,windowSize:i}=Xt(r,e);let c=t.ZERO,a=t.BASE;const u=BigInt(2**r-1),h=2**r,B=BigInt(r);for(let p=0;p<o;p++){const U=p*i;let w=Number(s&u);s>>=B,w>i&&(w-=h,s+=qt);const y=U,f=U+Math.abs(w)-1,g=p%2!==0,l=w<0;w===0?a=a.add(Wt(g,n[y])):c=c.add(Wt(l,n[f]))}return{p:c,f:a}},wNAFUnsafe(r,n,s,o=t.ZERO){const{windows:i,windowSize:c}=Xt(r,e),a=BigInt(2**r-1),u=2**r,h=BigInt(r);for(let B=0;B<i;B++){const p=B*c;if(s===Ne)break;let U=Number(s&a);if(s>>=h,U>c&&(U-=u,s+=qt),U===0)continue;let w=n[p+Math.abs(U)-1];U<0&&(w=w.negate()),o=o.add(w)}return o},getPrecomputes(r,n,s){let o=$t.get(n);return o||(o=this.precomputeWindow(n,r),r!==1&&$t.set(n,s(o))),o},wNAFCached(r,n,s){const o=Jt(r);return this.wNAF(o,this.getPrecomputes(o,r,s),n)},wNAFCachedUnsafe(r,n,s,o){const i=Jt(r);return i===1?this.unsafeLadder(r,n,o):this.wNAFUnsafe(i,this.getPrecomputes(i,r,s),n,o)},setWindowSize(r,n){rr(n,e),nr.set(r,n),$t.delete(r)}}}function Pn(t,e,r,n){if(Tn(r,t),kn(n,e),r.length!==n.length)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO,o=We(BigInt(r.length)),i=o>12?o-3:o>4?o-2:o?2:1,c=(1<<i)-1,a=new Array(c+1).fill(s),u=Math.floor((e.BITS-1)/i)*i;let h=s;for(let B=u;B>=0;B-=i){a.fill(s);for(let U=0;U<n.length;U++){const w=n[U],y=Number(w>>BigInt(B)&BigInt(c));a[y]=a[y].add(r[U])}let p=s;for(let U=a.length-1,w=s;U>0;U--)w=w.add(a[U]),p=p.add(w);if(h=h.add(p),B!==0)for(let U=0;U<i;U++)h=h.double()}return h}function or(t){return On(t.Fp),It(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Je(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}BigInt(0),BigInt(1),BigInt(2),BigInt(8);const yt=BigInt(0),Qt=BigInt(1);function qn(t){return It(t,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...t})}function Fn(t){const e=qn(t),{P:r}=e,n=l=>$(l,r),s=e.montgomeryBits,o=Math.ceil(s/8),i=e.nByteLength,c=e.adjustScalarBytes||(l=>l),a=e.powPminus2||(l=>$e(l,r-BigInt(2),r));function u(l,A,O){const k=n(l*(A-O));return A=n(A-k),O=n(O+k),[A,O]}const h=(e.a-BigInt(2))/BigInt(4);function B(l,A){at("u",l,yt,r),at("scalar",A,yt,r);const O=A,k=l;let S=Qt,E=yt,I=l,x=Qt,R=yt,L;for(let P=BigInt(s-1);P>=yt;P--){const d=O>>P&Qt;R^=d,L=u(R,S,I),S=L[0],I=L[1],L=u(R,E,x),E=L[0],x=L[1],R=d;const b=S+E,m=n(b*b),N=S-E,_=n(N*N),v=m-_,F=I+x,q=I-x,C=n(q*b),H=n(F*N),M=C+H,G=C-H;I=n(M*M),x=n(k*n(G*G)),S=n(m*_),E=n(v*(m+n(h*v)))}L=u(R,S,I),S=L[0],I=L[1],L=u(R,E,x),E=L[0],x=L[1];const T=a(E);return n(S*T)}function p(l){return Ht(n(l),o)}function U(l){const A=Q("u coordinate",l,o);return i===32&&(A[31]&=127),Nt(A)}function w(l){const A=Q("scalar",l),O=A.length;if(O!==o&&O!==i){let k=""+o+" or "+i;throw new Error("invalid scalar, expected "+k+" bytes, got "+O)}return Nt(c(A))}function y(l,A){const O=U(A),k=w(l),S=B(O,k);if(S===yt)throw new Error("invalid private or public key received");return p(S)}const f=p(e.Gu);function g(l){return y(l,f)}return{scalarMult:y,scalarMultBase:g,getSharedSecret:(l,A)=>y(l,A),getPublicKey:l=>g(l),utils:{randomPrivateKey:()=>e.randomBytes(e.nByteLength)},GuBytes:f}}const ie=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");BigInt(0);const Cn=BigInt(1),Le=BigInt(2),zn=BigInt(3),jn=BigInt(5);BigInt(8);function Hn(t){const e=BigInt(10),r=BigInt(20),n=BigInt(40),s=BigInt(80),o=ie,i=t*t%o*t%o,c=et(i,Le,o)*i%o,a=et(c,Cn,o)*t%o,u=et(a,jn,o)*a%o,h=et(u,e,o)*u%o,B=et(h,r,o)*h%o,p=et(B,n,o)*B%o,U=et(p,s,o)*p%o,w=et(U,s,o)*p%o,y=et(w,e,o)*u%o;return{pow_p_5_8:et(y,Le,o)*t%o,b2:i}}function Mn(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}Fn({P:ie,a:BigInt(486662),montgomeryBits:255,nByteLength:32,Gu:BigInt(9),powPminus2:t=>{const e=ie,{pow_p_5_8:r,b2:n}=Hn(t);return $(et(r,zn,e)*n,e)},adjustScalarBytes:Mn,randomBytes:ze});function _e(t){t.lowS!==void 0&&xt("lowS",t.lowS),t.prehash!==void 0&&xt("prehash",t.prehash)}function Dn(t){const e=or(t);It(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:s}=e;if(r){if(!n.eql(s,n.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof r!="object"||typeof r.beta!="bigint"||typeof r.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Vn,hexToBytes:Zn}=An;class Yn extends Error{constructor(e=""){super(e)}}const st={Err:Yn,_tlv:{encode:(t,e)=>{const{Err:r}=st;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");const n=e.length/2,s=bt(n);if(s.length/2&128)throw new r("tlv.encode: long form length too big");const o=n>127?bt(s.length/2|128):"";return bt(t)+o+s+e},decode(t,e){const{Err:r}=st;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const s=e[n++],o=!!(s&128);let i=0;if(!o)i=s;else{const a=s&127;if(!a)throw new r("tlv.decode(long): indefinite length not supported");if(a>4)throw new r("tlv.decode(long): byte length is too big");const u=e.subarray(n,n+a);if(u.length!==a)throw new r("tlv.decode: length bytes not complete");if(u[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const h of u)i=i<<8|h;if(n+=a,i<128)throw new r("tlv.decode(long): not minimal encoding")}const c=e.subarray(n,n+i);if(c.length!==i)throw new r("tlv.decode: wrong value length");return{v:c,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=st;if(t<it)throw new e("integer: negative integers are not allowed");let r=bt(t);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=st;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return Vn(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=st,s=typeof t=="string"?Zn(t):t;Tt(s);const{v:o,l:i}=n.decode(48,s);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l:a}=n.decode(2,o),{v:u,l:h}=n.decode(2,a);if(h.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(c),s:r.decode(u)}},hexFromSig(t){const{_tlv:e,_int:r}=st,n=e.encode(2,r.encode(t.r)),s=e.encode(2,r.encode(t.s)),o=n+s;return e.encode(48,o)}},it=BigInt(0),V=BigInt(1);BigInt(2);const Te=BigInt(3);BigInt(4);function Kn(t){const e=Dn(t),{Fp:r}=e,n=Qe(e.n,e.nBitLength),s=e.toBytes||((y,f,g)=>{const l=f.toAffine();return Lt(Uint8Array.from([4]),r.toBytes(l.x),r.toBytes(l.y))}),o=e.fromBytes||(y=>{const f=y.subarray(1),g=r.fromBytes(f.subarray(0,r.BYTES)),l=r.fromBytes(f.subarray(r.BYTES,2*r.BYTES));return{x:g,y:l}});function i(y){const{a:f,b:g}=e,l=r.sqr(y),A=r.mul(l,y);return r.add(r.add(A,r.mul(y,f)),g)}if(!r.eql(r.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function c(y){return Mt(y,V,e.n)}function a(y){const{allowedPrivateKeyLengths:f,nByteLength:g,wrapPrivateKey:l,n:A}=e;if(f&&typeof y!="bigint"){if(gt(y)&&(y=Bt(y)),typeof y!="string"||!f.includes(y.length))throw new Error("invalid private key");y=y.padStart(g*2,"0")}let O;try{O=typeof y=="bigint"?y:pt(Q("private key",y,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof y)}return l&&(O=$(O,A)),at("private key",O,V,A),O}function u(y){if(!(y instanceof p))throw new Error("ProjectivePoint expected")}const h=ne((y,f)=>{const{px:g,py:l,pz:A}=y;if(r.eql(A,r.ONE))return{x:g,y:l};const O=y.is0();f==null&&(f=O?r.ONE:r.inv(A));const k=r.mul(g,f),S=r.mul(l,f),E=r.mul(A,f);if(O)return{x:r.ZERO,y:r.ZERO};if(!r.eql(E,r.ONE))throw new Error("invZ was invalid");return{x:k,y:S}}),B=ne(y=>{if(y.is0()){if(e.allowInfinityPoint&&!r.is0(y.py))return;throw new Error("bad point: ZERO")}const{x:f,y:g}=y.toAffine();if(!r.isValid(f)||!r.isValid(g))throw new Error("bad point: x or y not FE");const l=r.sqr(g),A=i(f);if(!r.eql(l,A))throw new Error("bad point: equation left != right");if(!y.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(f,g,l){if(this.px=f,this.py=g,this.pz=l,f==null||!r.isValid(f))throw new Error("x required");if(g==null||!r.isValid(g))throw new Error("y required");if(l==null||!r.isValid(l))throw new Error("z required");Object.freeze(this)}static fromAffine(f){const{x:g,y:l}=f||{};if(!f||!r.isValid(g)||!r.isValid(l))throw new Error("invalid affine point");if(f instanceof p)throw new Error("projective point not allowed");const A=O=>r.eql(O,r.ZERO);return A(g)&&A(l)?p.ZERO:new p(g,l,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const g=r.invertBatch(f.map(l=>l.pz));return f.map((l,A)=>l.toAffine(g[A])).map(p.fromAffine)}static fromHex(f){const g=p.fromAffine(o(Q("pointHex",f)));return g.assertValidity(),g}static fromPrivateKey(f){return p.BASE.multiply(a(f))}static msm(f,g){return Pn(p,n,f,g)}_setWindowSize(f){w.setWindowSize(this,f)}assertValidity(){B(this)}hasEvenY(){const{y:f}=this.toAffine();if(r.isOdd)return!r.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){u(f);const{px:g,py:l,pz:A}=this,{px:O,py:k,pz:S}=f,E=r.eql(r.mul(g,S),r.mul(O,A)),I=r.eql(r.mul(l,S),r.mul(k,A));return E&&I}negate(){return new p(this.px,r.neg(this.py),this.pz)}double(){const{a:f,b:g}=e,l=r.mul(g,Te),{px:A,py:O,pz:k}=this;let S=r.ZERO,E=r.ZERO,I=r.ZERO,x=r.mul(A,A),R=r.mul(O,O),L=r.mul(k,k),T=r.mul(A,O);return T=r.add(T,T),I=r.mul(A,k),I=r.add(I,I),S=r.mul(f,I),E=r.mul(l,L),E=r.add(S,E),S=r.sub(R,E),E=r.add(R,E),E=r.mul(S,E),S=r.mul(T,S),I=r.mul(l,I),L=r.mul(f,L),T=r.sub(x,L),T=r.mul(f,T),T=r.add(T,I),I=r.add(x,x),x=r.add(I,x),x=r.add(x,L),x=r.mul(x,T),E=r.add(E,x),L=r.mul(O,k),L=r.add(L,L),x=r.mul(L,T),S=r.sub(S,x),I=r.mul(L,R),I=r.add(I,I),I=r.add(I,I),new p(S,E,I)}add(f){u(f);const{px:g,py:l,pz:A}=this,{px:O,py:k,pz:S}=f;let E=r.ZERO,I=r.ZERO,x=r.ZERO;const R=e.a,L=r.mul(e.b,Te);let T=r.mul(g,O),P=r.mul(l,k),d=r.mul(A,S),b=r.add(g,l),m=r.add(O,k);b=r.mul(b,m),m=r.add(T,P),b=r.sub(b,m),m=r.add(g,A);let N=r.add(O,S);return m=r.mul(m,N),N=r.add(T,d),m=r.sub(m,N),N=r.add(l,A),E=r.add(k,S),N=r.mul(N,E),E=r.add(P,d),N=r.sub(N,E),x=r.mul(R,m),E=r.mul(L,d),x=r.add(E,x),E=r.sub(P,x),x=r.add(P,x),I=r.mul(E,x),P=r.add(T,T),P=r.add(P,T),d=r.mul(R,d),m=r.mul(L,m),P=r.add(P,d),d=r.sub(T,d),d=r.mul(R,d),m=r.add(m,d),T=r.mul(P,m),I=r.add(I,T),T=r.mul(N,m),E=r.mul(b,E),E=r.sub(E,T),T=r.mul(b,P),x=r.mul(N,x),x=r.add(x,T),new p(E,I,x)}subtract(f){return this.add(f.negate())}is0(){return this.equals(p.ZERO)}wNAF(f){return w.wNAFCached(this,f,p.normalizeZ)}multiplyUnsafe(f){const{endo:g,n:l}=e;at("scalar",f,it,l);const A=p.ZERO;if(f===it)return A;if(this.is0()||f===V)return this;if(!g||w.hasPrecomputes(this))return w.wNAFCachedUnsafe(this,f,p.normalizeZ);let{k1neg:O,k1:k,k2neg:S,k2:E}=g.splitScalar(f),I=A,x=A,R=this;for(;k>it||E>it;)k&V&&(I=I.add(R)),E&V&&(x=x.add(R)),R=R.double(),k>>=V,E>>=V;return O&&(I=I.negate()),S&&(x=x.negate()),x=new p(r.mul(x.px,g.beta),x.py,x.pz),I.add(x)}multiply(f){const{endo:g,n:l}=e;at("scalar",f,V,l);let A,O;if(g){const{k1neg:k,k1:S,k2neg:E,k2:I}=g.splitScalar(f);let{p:x,f:R}=this.wNAF(S),{p:L,f:T}=this.wNAF(I);x=w.constTimeNegate(k,x),L=w.constTimeNegate(E,L),L=new p(r.mul(L.px,g.beta),L.py,L.pz),A=x.add(L),O=R.add(T)}else{const{p:k,f:S}=this.wNAF(f);A=k,O=S}return p.normalizeZ([A,O])[0]}multiplyAndAddUnsafe(f,g,l){const A=p.BASE,O=(S,E)=>E===it||E===V||!S.equals(A)?S.multiplyUnsafe(E):S.multiply(E),k=O(this,g).add(O(f,l));return k.is0()?void 0:k}toAffine(f){return h(this,f)}isTorsionFree(){const{h:f,isTorsionFree:g}=e;if(f===V)return!0;if(g)return g(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:g}=e;return f===V?this:g?g(p,this):this.multiplyUnsafe(e.h)}toRawBytes(f=!0){return xt("isCompressed",f),this.assertValidity(),s(p,this,f)}toHex(f=!0){return xt("isCompressed",f),Bt(this.toRawBytes(f))}}p.BASE=new p(e.Gx,e.Gy,r.ONE),p.ZERO=new p(r.ZERO,r.ONE,r.ZERO);const U=e.nBitLength,w=Rn(p,e.endo?Math.ceil(U/2):U);return{CURVE:e,ProjectivePoint:p,normPrivateKeyToScalar:a,weierstrassEquation:i,isWithinCurveOrder:c}}function Gn(t){const e=or(t);return It(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Wn(t){const e=Gn(t),{Fp:r,n}=e,s=r.BYTES+1,o=2*r.BYTES+1;function i(d){return $(d,n)}function c(d){return se(d,n)}const{ProjectivePoint:a,normPrivateKeyToScalar:u,weierstrassEquation:h,isWithinCurveOrder:B}=Kn({...e,toBytes(d,b,m){const N=b.toAffine(),_=r.toBytes(N.x),v=Lt;return xt("isCompressed",m),m?v(Uint8Array.from([b.hasEvenY()?2:3]),_):v(Uint8Array.from([4]),_,r.toBytes(N.y))},fromBytes(d){const b=d.length,m=d[0],N=d.subarray(1);if(b===s&&(m===2||m===3)){const _=pt(N);if(!Mt(_,V,r.ORDER))throw new Error("Point is not on curve");const v=h(_);let F;try{F=r.sqrt(v)}catch(C){const H=C instanceof Error?": "+C.message:"";throw new Error("Point is not on curve"+H)}const q=(F&V)===V;return(m&1)===1!==q&&(F=r.neg(F)),{x:_,y:F}}else if(b===o&&m===4){const _=r.fromBytes(N.subarray(0,r.BYTES)),v=r.fromBytes(N.subarray(r.BYTES,2*r.BYTES));return{x:_,y:v}}else{const _=s,v=o;throw new Error("invalid Point, expected length of "+_+", or uncompressed "+v+", got "+b)}}}),p=d=>Bt(vt(d,e.nByteLength));function U(d){const b=n>>V;return d>b}function w(d){return U(d)?i(-d):d}const y=(d,b,m)=>pt(d.slice(b,m));class f{constructor(b,m,N){this.r=b,this.s=m,this.recovery=N,this.assertValidity()}static fromCompact(b){const m=e.nByteLength;return b=Q("compactSignature",b,m*2),new f(y(b,0,m),y(b,m,2*m))}static fromDER(b){const{r:m,s:N}=st.toSig(Q("DER",b));return new f(m,N)}assertValidity(){at("r",this.r,V,n),at("s",this.s,V,n)}addRecoveryBit(b){return new f(this.r,this.s,b)}recoverPublicKey(b){const{r:m,s:N,recovery:_}=this,v=S(Q("msgHash",b));if(_==null||![0,1,2,3].includes(_))throw new Error("recovery id invalid");const F=_===2||_===3?m+e.n:m;if(F>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const q=_&1?"03":"02",C=a.fromHex(q+p(F)),H=c(F),M=i(-v*H),G=i(N*H),W=a.BASE.multiplyAndAddUnsafe(C,M,G);if(!W)throw new Error("point at infinify");return W.assertValidity(),W}hasHighS(){return U(this.s)}normalizeS(){return this.hasHighS()?new f(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return At(this.toDERHex())}toDERHex(){return st.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return At(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const g={isValidPrivateKey(d){try{return u(d),!0}catch{return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const d=er(e.n);return _n(e.randomBytes(d),e.n)},precompute(d=8,b=a.BASE){return b._setWindowSize(d),b.multiply(BigInt(3)),b}};function l(d,b=!0){return a.fromPrivateKey(d).toRawBytes(b)}function A(d){const b=gt(d),m=typeof d=="string",N=(b||m)&&d.length;return b?N===s||N===o:m?N===2*s||N===2*o:d instanceof a}function O(d,b,m=!0){if(A(d))throw new Error("first arg must be private key");if(!A(b))throw new Error("second arg must be public key");return a.fromHex(b).multiply(u(d)).toRawBytes(m)}const k=e.bits2int||function(d){if(d.length>8192)throw new Error("input is too large");const b=pt(d),m=d.length*8-e.nBitLength;return m>0?b>>BigInt(m):b},S=e.bits2int_modN||function(d){return i(k(d))},E=he(e.nBitLength);function I(d){return at("num < 2^"+e.nBitLength,d,it,E),vt(d,e.nByteLength)}function x(d,b,m=R){if(["recovered","canonical"].some(X=>X in m))throw new Error("sign() legacy options not supported");const{hash:N,randomBytes:_}=e;let{lowS:v,prehash:F,extraEntropy:q}=m;v==null&&(v=!0),d=Q("msgHash",d),_e(m),F&&(d=Q("prehashed msgHash",N(d)));const C=S(d),H=u(b),M=[I(H),I(C)];if(q!=null&&q!==!1){const X=q===!0?_(r.BYTES):q;M.push(Q("extraEntropy",X))}const G=Lt(...M),W=C;function rt(X){const J=k(X);if(!B(J))return;const Vt=c(J),Ut=a.BASE.multiply(J).toAffine(),ht=i(Ut.x);if(ht===it)return;const lt=i(Vt*i(W+ht*H));if(lt===it)return;let St=(Ut.x===ht?0:2)|Number(Ut.y&V),le=lt;return v&&U(lt)&&(le=w(lt),St^=1),new f(ht,le,St)}return{seed:G,k2sig:rt}}const R={lowS:e.lowS,prehash:!1},L={lowS:e.lowS,prehash:!1};function T(d,b,m=R){const{seed:N,k2sig:_}=x(d,b,m),v=e;return Xe(v.hash.outputLen,v.nByteLength,v.hmac)(N,_)}a.BASE._setWindowSize(8);function P(d,b,m,N=L){var lt;const _=d;b=Q("msgHash",b),m=Q("publicKey",m);const{lowS:v,prehash:F,format:q}=N;if(_e(N),"strict"in N)throw new Error("options.strict was renamed to lowS");if(q!==void 0&&q!=="compact"&&q!=="der")throw new Error("format must be compact or der");const C=typeof _=="string"||gt(_),H=!C&&!q&&typeof _=="object"&&_!==null&&typeof _.r=="bigint"&&typeof _.s=="bigint";if(!C&&!H)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let M,G;try{if(H&&(M=new f(_.r,_.s)),C){try{q!=="compact"&&(M=f.fromDER(_))}catch(St){if(!(St instanceof st.Err))throw St}!M&&q!=="der"&&(M=f.fromCompact(_))}G=a.fromHex(m)}catch{return!1}if(!M||v&&M.hasHighS())return!1;F&&(b=e.hash(b));const{r:W,s:rt}=M,X=S(b),J=c(rt),Vt=i(X*J),Ut=i(W*J),ht=(lt=a.BASE.multiplyAndAddUnsafe(G,Vt,Ut))==null?void 0:lt.toAffine();return ht?i(ht.x)===W:!1}return{CURVE:e,getPublicKey:l,getSharedSecret:O,sign:T,verify:P,ProjectivePoint:a,Signature:f,utils:g}}function Xn(t){return{hash:t,hmac:(e,...r)=>Ge(t,e,Ur(...r)),randomBytes:ze}}function $n(t,e){const r=n=>Wn({...t,...Xn(n)});return{...r(e),create:r}}const sr=Qe(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),Jn=sr.create(BigInt("-3")),Qn=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");$n({a:Jn,b:Qn,Fp:sr,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},dn);z.ONE_DAY;z.SIX_HOURS;z.ONE_DAY,z.ONE_DAY,z.THIRTY_SECONDS,z.THIRTY_SECONDS,z.ONE_DAY,z.ONE_DAY;function to(t,e){if(t.length>=255)throw new TypeError("Alphabet too long");for(var r=new Uint8Array(256),n=0;n<r.length;n++)r[n]=255;for(var s=0;s<t.length;s++){var o=t.charAt(s),i=o.charCodeAt(0);if(r[i]!==255)throw new TypeError(o+" is ambiguous");r[i]=s}var c=t.length,a=t.charAt(0),u=Math.log(c)/Math.log(256),h=Math.log(256)/Math.log(c);function B(w){if(w instanceof Uint8Array||(ArrayBuffer.isView(w)?w=new Uint8Array(w.buffer,w.byteOffset,w.byteLength):Array.isArray(w)&&(w=Uint8Array.from(w))),!(w instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(w.length===0)return"";for(var y=0,f=0,g=0,l=w.length;g!==l&&w[g]===0;)g++,y++;for(var A=(l-g)*h+1>>>0,O=new Uint8Array(A);g!==l;){for(var k=w[g],S=0,E=A-1;(k!==0||S<f)&&E!==-1;E--,S++)k+=256*O[E]>>>0,O[E]=k%c>>>0,k=k/c>>>0;if(k!==0)throw new Error("Non-zero carry");f=S,g++}for(var I=A-f;I!==A&&O[I]===0;)I++;for(var x=a.repeat(y);I<A;++I)x+=t.charAt(O[I]);return x}function p(w){if(typeof w!="string")throw new TypeError("Expected String");if(w.length===0)return new Uint8Array;var y=0;if(w[y]!==" "){for(var f=0,g=0;w[y]===a;)f++,y++;for(var l=(w.length-y)*u+1>>>0,A=new Uint8Array(l);w[y];){var O=r[w.charCodeAt(y)];if(O===255)return;for(var k=0,S=l-1;(O!==0||k<g)&&S!==-1;S--,k++)O+=c*A[S]>>>0,A[S]=O%256>>>0,O=O/256>>>0;if(O!==0)throw new Error("Non-zero carry");g=k,y++}if(w[y]!==" "){for(var E=l-g;E!==l&&A[E]===0;)E++;for(var I=new Uint8Array(f+(l-E)),x=f;E!==l;)I[x++]=A[E++];return I}}}function U(w){var y=p(w);if(y)return y;throw new Error(`Non-${e} character`)}return{encode:B,decodeUnsafe:p,decode:U}}var eo=to,ro=eo;const ir=t=>{if(t instanceof Uint8Array&&t.constructor.name==="Uint8Array")return t;if(t instanceof ArrayBuffer)return new Uint8Array(t);if(ArrayBuffer.isView(t))return new Uint8Array(t.buffer,t.byteOffset,t.byteLength);throw new Error("Unknown type, must be binary type")},no=t=>new TextEncoder().encode(t),oo=t=>new TextDecoder().decode(t);class so{constructor(e,r,n){this.name=e,this.prefix=r,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class io{constructor(e,r,n){if(this.name=e,this.prefix=r,r.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=r.codePointAt(0),this.baseDecode=n}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return ar(this,e)}}class ao{constructor(e){this.decoders=e}or(e){return ar(this,e)}decode(e){const r=e[0],n=this.decoders[r];if(n)return n.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const ar=(t,e)=>new ao({...t.decoders||{[t.prefix]:t},...e.decoders||{[e.prefix]:e}});class co{constructor(e,r,n,s){this.name=e,this.prefix=r,this.baseEncode=n,this.baseDecode=s,this.encoder=new so(e,r,n),this.decoder=new io(e,r,s)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const Dt=({name:t,prefix:e,encode:r,decode:n})=>new co(t,e,r,n),kt=({prefix:t,name:e,alphabet:r})=>{const{encode:n,decode:s}=ro(r,e);return Dt({prefix:t,name:e,encode:n,decode:o=>ir(s(o))})},fo=(t,e,r,n)=>{const s={};for(let h=0;h<e.length;++h)s[e[h]]=h;let o=t.length;for(;t[o-1]==="=";)--o;const i=new Uint8Array(o*r/8|0);let c=0,a=0,u=0;for(let h=0;h<o;++h){const B=s[t[h]];if(B===void 0)throw new SyntaxError(`Non-${n} character`);a=a<<r|B,c+=r,c>=8&&(c-=8,i[u++]=255&a>>c)}if(c>=r||255&a<<8-c)throw new SyntaxError("Unexpected end of data");return i},uo=(t,e,r)=>{const n=e[e.length-1]==="=",s=(1<<r)-1;let o="",i=0,c=0;for(let a=0;a<t.length;++a)for(c=c<<8|t[a],i+=8;i>r;)i-=r,o+=e[s&c>>i];if(i&&(o+=e[s&c<<r-i]),n)for(;o.length*r&7;)o+="=";return o},K=({name:t,prefix:e,bitsPerChar:r,alphabet:n})=>Dt({prefix:e,name:t,encode(s){return uo(s,n,r)},decode(s){return fo(s,n,r,t)}}),ho=Dt({prefix:"\0",name:"identity",encode:t=>oo(t),decode:t=>no(t)});var lo=Object.freeze({__proto__:null,identity:ho});const po=K({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var go=Object.freeze({__proto__:null,base2:po});const wo=K({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var yo=Object.freeze({__proto__:null,base8:wo});const bo=kt({prefix:"9",name:"base10",alphabet:"0123456789"});var mo=Object.freeze({__proto__:null,base10:bo});const Eo=K({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),xo=K({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Bo=Object.freeze({__proto__:null,base16:Eo,base16upper:xo});const Ao=K({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),vo=K({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Io=K({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Uo=K({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),So=K({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Oo=K({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),No=K({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Lo=K({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),_o=K({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var To=Object.freeze({__proto__:null,base32:Ao,base32upper:vo,base32pad:Io,base32padupper:Uo,base32hex:So,base32hexupper:Oo,base32hexpad:No,base32hexpadupper:Lo,base32z:_o});const ko=kt({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Ro=kt({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Po=Object.freeze({__proto__:null,base36:ko,base36upper:Ro});const qo=kt({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Fo=kt({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Co=Object.freeze({__proto__:null,base58btc:qo,base58flickr:Fo});const zo=K({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),jo=K({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Ho=K({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Mo=K({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Do=Object.freeze({__proto__:null,base64:zo,base64pad:jo,base64url:Ho,base64urlpad:Mo});const cr=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Vo=cr.reduce((t,e,r)=>(t[r]=e,t),[]),Zo=cr.reduce((t,e,r)=>(t[e.codePointAt(0)]=r,t),[]);function Yo(t){return t.reduce((e,r)=>(e+=Vo[r],e),"")}function Ko(t){const e=[];for(const r of t){const n=Zo[r.codePointAt(0)];if(n===void 0)throw new Error(`Non-base256emoji character: ${r}`);e.push(n)}return new Uint8Array(e)}const Go=Dt({prefix:"🚀",name:"base256emoji",encode:Yo,decode:Ko});var Wo=Object.freeze({__proto__:null,base256emoji:Go}),Xo=fr,ke=128,$o=-128,Jo=Math.pow(2,31);function fr(t,e,r){e=e||[],r=r||0;for(var n=r;t>=Jo;)e[r++]=t&255|ke,t/=128;for(;t&$o;)e[r++]=t&255|ke,t>>>=7;return e[r]=t|0,fr.bytes=r-n+1,e}var Qo=ae,ts=128,Re=127;function ae(t,n){var r=0,n=n||0,s=0,o=n,i,c=t.length;do{if(o>=c)throw ae.bytes=0,new RangeError("Could not decode varint");i=t[o++],r+=s<28?(i&Re)<<s:(i&Re)*Math.pow(2,s),s+=7}while(i>=ts);return ae.bytes=o-n,r}var es=Math.pow(2,7),rs=Math.pow(2,14),ns=Math.pow(2,21),os=Math.pow(2,28),ss=Math.pow(2,35),is=Math.pow(2,42),as=Math.pow(2,49),cs=Math.pow(2,56),fs=Math.pow(2,63),us=function(t){return t<es?1:t<rs?2:t<ns?3:t<os?4:t<ss?5:t<is?6:t<as?7:t<cs?8:t<fs?9:10},hs={encode:Xo,decode:Qo,encodingLength:us},ur=hs;const Pe=(t,e,r=0)=>(ur.encode(t,e,r),e),qe=t=>ur.encodingLength(t),ce=(t,e)=>{const r=e.byteLength,n=qe(t),s=n+qe(r),o=new Uint8Array(s+r);return Pe(t,o,0),Pe(r,o,n),o.set(e,s),new ls(t,r,e,o)};class ls{constructor(e,r,n,s){this.code=e,this.size=r,this.digest=n,this.bytes=s}}const hr=({name:t,code:e,encode:r})=>new ds(t,e,r);class ds{constructor(e,r,n){this.name=e,this.code=r,this.encode=n}digest(e){if(e instanceof Uint8Array){const r=this.encode(e);return r instanceof Uint8Array?ce(this.code,r):r.then(n=>ce(this.code,n))}else throw Error("Unknown type, must be binary type")}}const lr=t=>async e=>new Uint8Array(await crypto.subtle.digest(t,e)),ps=hr({name:"sha2-256",code:18,encode:lr("SHA-256")}),gs=hr({name:"sha2-512",code:19,encode:lr("SHA-512")});var ws=Object.freeze({__proto__:null,sha256:ps,sha512:gs});const dr=0,ys="identity",pr=ir,bs=t=>ce(dr,pr(t)),ms={code:dr,name:ys,encode:pr,digest:bs};var Es=Object.freeze({__proto__:null,identity:ms});new TextEncoder,new TextDecoder;({...lo,...go,...yo,...mo,...Bo,...To,...Po,...Co,...Do,...Wo});({...ws,...Es});z.SEVEN_DAYS;z.FIVE_MINUTES,z.FIVE_MINUTES,z.FIVE_MINUTES,z.FIVE_MINUTES,z.FIVE_MINUTES,z.FIVE_MINUTES,z.ONE_DAY,z.ONE_DAY,z.ONE_DAY,z.ONE_DAY,z.FIVE_MINUTES,z.FIVE_MINUTES,z.FIVE_MINUTES,z.FIVE_MINUTES,z.ONE_DAY,z.ONE_DAY,z.ONE_DAY,z.ONE_DAY,z.ONE_HOUR,z.ONE_HOUR,z.FIVE_MINUTES,z.FIVE_MINUTES;z.FIVE_MINUTES,z.SEVEN_DAYS;
